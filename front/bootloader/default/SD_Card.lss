
SD_Card.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800100  0000ef3a  00000fce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f3a  0000e000  0000e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000247  0080018e  0080018e  0000105c  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  0000105c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000090  00000000  00000000  00001728  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  000017b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000005da  00000000  00000000  00001998  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c01  00000000  00000000  00001f72  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000928  00000000  00000000  00003b73  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000190c  00000000  00000000  0000449b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000002c0  00000000  00000000  00005da8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000834  00000000  00000000  00006068  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000bed  00000000  00000000  0000689c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 000001a4  00000000  00000000  00007489  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000190  00000000  00000000  0000762d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000e000 <__vectors>:
    e000:	37 c0       	rjmp	.+110    	; 0xe070 <__ctors_end>
    e002:	00 00       	nop
    e004:	50 c0       	rjmp	.+160    	; 0xe0a6 <__bad_interrupt>
    e006:	00 00       	nop
    e008:	4e c0       	rjmp	.+156    	; 0xe0a6 <__bad_interrupt>
    e00a:	00 00       	nop
    e00c:	4c c0       	rjmp	.+152    	; 0xe0a6 <__bad_interrupt>
    e00e:	00 00       	nop
    e010:	4a c0       	rjmp	.+148    	; 0xe0a6 <__bad_interrupt>
    e012:	00 00       	nop
    e014:	48 c0       	rjmp	.+144    	; 0xe0a6 <__bad_interrupt>
    e016:	00 00       	nop
    e018:	46 c0       	rjmp	.+140    	; 0xe0a6 <__bad_interrupt>
    e01a:	00 00       	nop
    e01c:	44 c0       	rjmp	.+136    	; 0xe0a6 <__bad_interrupt>
    e01e:	00 00       	nop
    e020:	42 c0       	rjmp	.+132    	; 0xe0a6 <__bad_interrupt>
    e022:	00 00       	nop
    e024:	40 c0       	rjmp	.+128    	; 0xe0a6 <__bad_interrupt>
    e026:	00 00       	nop
    e028:	3e c0       	rjmp	.+124    	; 0xe0a6 <__bad_interrupt>
    e02a:	00 00       	nop
    e02c:	3c c0       	rjmp	.+120    	; 0xe0a6 <__bad_interrupt>
    e02e:	00 00       	nop
    e030:	3a c0       	rjmp	.+116    	; 0xe0a6 <__bad_interrupt>
    e032:	00 00       	nop
    e034:	38 c0       	rjmp	.+112    	; 0xe0a6 <__bad_interrupt>
    e036:	00 00       	nop
    e038:	36 c0       	rjmp	.+108    	; 0xe0a6 <__bad_interrupt>
    e03a:	00 00       	nop
    e03c:	34 c0       	rjmp	.+104    	; 0xe0a6 <__bad_interrupt>
    e03e:	00 00       	nop
    e040:	32 c0       	rjmp	.+100    	; 0xe0a6 <__bad_interrupt>
    e042:	00 00       	nop
    e044:	30 c0       	rjmp	.+96     	; 0xe0a6 <__bad_interrupt>
    e046:	00 00       	nop
    e048:	2e c0       	rjmp	.+92     	; 0xe0a6 <__bad_interrupt>
    e04a:	00 00       	nop
    e04c:	2c c0       	rjmp	.+88     	; 0xe0a6 <__bad_interrupt>
    e04e:	00 00       	nop
    e050:	2a c0       	rjmp	.+84     	; 0xe0a6 <__bad_interrupt>
    e052:	00 00       	nop
    e054:	28 c0       	rjmp	.+80     	; 0xe0a6 <__bad_interrupt>
    e056:	00 00       	nop
    e058:	26 c0       	rjmp	.+76     	; 0xe0a6 <__bad_interrupt>
    e05a:	00 00       	nop
    e05c:	24 c0       	rjmp	.+72     	; 0xe0a6 <__bad_interrupt>
    e05e:	00 00       	nop
    e060:	22 c0       	rjmp	.+68     	; 0xe0a6 <__bad_interrupt>
    e062:	00 00       	nop
    e064:	20 c0       	rjmp	.+64     	; 0xe0a6 <__bad_interrupt>
    e066:	00 00       	nop
    e068:	1e c0       	rjmp	.+60     	; 0xe0a6 <__bad_interrupt>
    e06a:	00 00       	nop
    e06c:	1c c0       	rjmp	.+56     	; 0xe0a6 <__bad_interrupt>
	...

0000e070 <__ctors_end>:
    e070:	11 24       	eor	r1, r1
    e072:	1f be       	out	0x3f, r1	; 63
    e074:	cf ef       	ldi	r28, 0xFF	; 255
    e076:	d0 e1       	ldi	r29, 0x10	; 16
    e078:	de bf       	out	0x3e, r29	; 62
    e07a:	cd bf       	out	0x3d, r28	; 61

0000e07c <__do_copy_data>:
    e07c:	11 e0       	ldi	r17, 0x01	; 1
    e07e:	a0 e0       	ldi	r26, 0x00	; 0
    e080:	b1 e0       	ldi	r27, 0x01	; 1
    e082:	ea e3       	ldi	r30, 0x3A	; 58
    e084:	ff ee       	ldi	r31, 0xEF	; 239
    e086:	02 c0       	rjmp	.+4      	; 0xe08c <__do_copy_data+0x10>
    e088:	05 90       	lpm	r0, Z+
    e08a:	0d 92       	st	X+, r0
    e08c:	ae 38       	cpi	r26, 0x8E	; 142
    e08e:	b1 07       	cpc	r27, r17
    e090:	d9 f7       	brne	.-10     	; 0xe088 <__do_copy_data+0xc>

0000e092 <__do_clear_bss>:
    e092:	13 e0       	ldi	r17, 0x03	; 3
    e094:	ae e8       	ldi	r26, 0x8E	; 142
    e096:	b1 e0       	ldi	r27, 0x01	; 1
    e098:	01 c0       	rjmp	.+2      	; 0xe09c <.do_clear_bss_start>

0000e09a <.do_clear_bss_loop>:
    e09a:	1d 92       	st	X+, r1

0000e09c <.do_clear_bss_start>:
    e09c:	a5 3d       	cpi	r26, 0xD5	; 213
    e09e:	b1 07       	cpc	r27, r17
    e0a0:	e1 f7       	brne	.-8      	; 0xe09a <.do_clear_bss_loop>
    e0a2:	36 d5       	rcall	.+2668   	; 0xeb10 <main>
    e0a4:	48 c7       	rjmp	.+3728   	; 0xef36 <_exit>

0000e0a6 <__bad_interrupt>:
    e0a6:	ac cf       	rjmp	.-168    	; 0xe000 <__vectors>

0000e0a8 <_crc_xmodem_update>:
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    e0a8:	9c 01       	movw	r18, r24
    e0aa:	36 27       	eor	r19, r22
    e0ac:	03 2e       	mov	r0, r19
    e0ae:	02 94       	swap	r0
    e0b0:	80 2d       	mov	r24, r0
    e0b2:	8f 70       	andi	r24, 0x0F	; 15
    e0b4:	83 27       	eor	r24, r19
    e0b6:	63 2f       	mov	r22, r19
    e0b8:	60 25       	eor	r22, r0
    e0ba:	66 0f       	add	r22, r22
    e0bc:	60 7e       	andi	r22, 0xE0	; 224
    e0be:	86 27       	eor	r24, r22
    e0c0:	60 2d       	mov	r22, r0
    e0c2:	63 27       	eor	r22, r19
    e0c4:	60 7f       	andi	r22, 0xF0	; 240
    e0c6:	66 95       	lsr	r22
    e0c8:	03 2e       	mov	r0, r19
    e0ca:	00 0c       	add	r0, r0
    e0cc:	66 1f       	adc	r22, r22
    e0ce:	36 95       	lsr	r19
    e0d0:	36 95       	lsr	r19
    e0d2:	36 95       	lsr	r19
    e0d4:	3f 71       	andi	r19, 0x1F	; 31
    e0d6:	36 27       	eor	r19, r22
    e0d8:	32 27       	eor	r19, r18
    e0da:	28 2f       	mov	r18, r24
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
    e0dc:	c9 01       	movw	r24, r18
    e0de:	08 95       	ret

0000e0e0 <calcCrc>:
volatile uint32_t addressCounter=0;



uint16_t calcCrc(uint8_t cmd, uint8_t* data)
{
    e0e0:	cf 93       	push	r28
    e0e2:	df 93       	push	r29
    e0e4:	28 2f       	mov	r18, r24
    e0e6:	eb 01       	movw	r28, r22
	uint16_t crc=0;
	
	crc = _crc_xmodem_update(crc,cmd);
    e0e8:	80 e0       	ldi	r24, 0x00	; 0
    e0ea:	90 e0       	ldi	r25, 0x00	; 0
    e0ec:	62 2f       	mov	r22, r18
    e0ee:	dc df       	rcall	.-72     	; 0xe0a8 <_crc_xmodem_update>
	crc = _crc_xmodem_update(crc,data[3]);
    e0f0:	6b 81       	ldd	r22, Y+3	; 0x03
    e0f2:	da df       	rcall	.-76     	; 0xe0a8 <_crc_xmodem_update>
	crc = _crc_xmodem_update(crc,data[2]);
    e0f4:	6a 81       	ldd	r22, Y+2	; 0x02
    e0f6:	d8 df       	rcall	.-80     	; 0xe0a8 <_crc_xmodem_update>
	crc = _crc_xmodem_update(crc,data[1]);
    e0f8:	69 81       	ldd	r22, Y+1	; 0x01
    e0fa:	d6 df       	rcall	.-84     	; 0xe0a8 <_crc_xmodem_update>
	crc = _crc_xmodem_update(crc,data[0]);
    e0fc:	68 81       	ld	r22, Y
    e0fe:	d4 df       	rcall	.-88     	; 0xe0a8 <_crc_xmodem_update>
	
	return crc;
}
    e100:	df 91       	pop	r29
    e102:	cf 91       	pop	r28
    e104:	08 95       	ret

0000e106 <boot_program_page>:
//------------------------------------------------------------------------
void boot_program_page (uint32_t page, uint8_t *buf)
{
    e106:	0f 93       	push	r16
    e108:	1f 93       	push	r17
    e10a:	cf 93       	push	r28
    e10c:	df 93       	push	r29
    e10e:	da 01       	movw	r26, r20
    uint16_t i;
    uint8_t sreg;
 
    /* Disable interrupts.*/
    sreg = SREG;
    e110:	1f b7       	in	r17, 0x3f	; 63
    cli();
    e112:	f8 94       	cli
 
    eeprom_busy_wait ();
    e114:	f9 99       	sbic	0x1f, 1	; 31
    e116:	fe cf       	rjmp	.-4      	; 0xe114 <boot_program_page+0xe>
 
    boot_page_erase (page);
    e118:	83 e0       	ldi	r24, 0x03	; 3
    e11a:	fb 01       	movw	r30, r22
    e11c:	80 93 57 00 	sts	0x0057, r24
    e120:	e8 95       	spm
    boot_spm_busy_wait ();      /* Wait until the memory is erased. */
    e122:	07 b6       	in	r0, 0x37	; 55
    e124:	00 fc       	sbrc	r0, 0
    e126:	fd cf       	rjmp	.-6      	; 0xe122 <boot_program_page+0x1c>
	crc = _crc_xmodem_update(crc,data[0]);
	
	return crc;
}
//------------------------------------------------------------------------
void boot_program_page (uint32_t page, uint8_t *buf)
    e128:	cb 01       	movw	r24, r22
    e12a:	80 50       	subi	r24, 0x00	; 0
    e12c:	9f 4f       	sbci	r25, 0xFF	; 255
    e12e:	fb 01       	movw	r30, r22
    boot_spm_busy_wait ();      /* Wait until the memory is erased. */
 
    for (i=0; i<SPM_PAGESIZE; i+=2)
    {
        /* Set up little-endian word. */
        uint16_t w = *buf++;
    e130:	4c 91       	ld	r20, X
        w += (*buf++) << 8;
    e132:	11 96       	adiw	r26, 0x01	; 1
    e134:	3c 91       	ld	r19, X
    e136:	11 97       	sbiw	r26, 0x01	; 1
    e138:	20 e0       	ldi	r18, 0x00	; 0
    e13a:	e9 01       	movw	r28, r18
    e13c:	c4 0f       	add	r28, r20
    e13e:	d1 1d       	adc	r29, r1
	crc = _crc_xmodem_update(crc,data[0]);
	
	return crc;
}
//------------------------------------------------------------------------
void boot_program_page (uint32_t page, uint8_t *buf)
    e140:	12 96       	adiw	r26, 0x02	; 2
    {
        /* Set up little-endian word. */
        uint16_t w = *buf++;
        w += (*buf++) << 8;
    
        boot_page_fill (page + i, w);
    e142:	01 e0       	ldi	r16, 0x01	; 1
    e144:	0e 01       	movw	r0, r28
    e146:	00 93 57 00 	sts	0x0057, r16
    e14a:	e8 95       	spm
    e14c:	11 24       	eor	r1, r1
    e14e:	32 96       	adiw	r30, 0x02	; 2
    eeprom_busy_wait ();
 
    boot_page_erase (page);
    boot_spm_busy_wait ();      /* Wait until the memory is erased. */
 
    for (i=0; i<SPM_PAGESIZE; i+=2)
    e150:	e8 17       	cp	r30, r24
    e152:	f9 07       	cpc	r31, r25
    e154:	69 f7       	brne	.-38     	; 0xe130 <boot_program_page+0x2a>
        w += (*buf++) << 8;
    
        boot_page_fill (page + i, w);
		//boot_page_fill (page + i, page&0xffff);
    }
    boot_page_write (page);     /* Store buffer in flash page.		*/
    e156:	85 e0       	ldi	r24, 0x05	; 5
    e158:	fb 01       	movw	r30, r22
    e15a:	80 93 57 00 	sts	0x0057, r24
    e15e:	e8 95       	spm
    boot_spm_busy_wait();       /* Wait until the memory is written.*/
    e160:	07 b6       	in	r0, 0x37	; 55
    e162:	00 fc       	sbrc	r0, 0
    e164:	fd cf       	rjmp	.-6      	; 0xe160 <boot_program_page+0x5a>
 
    /* Reenable RWW-section again. We need this if we want to jump back */
    /* to the application after bootloading. */
    boot_rww_enable ();
    e166:	81 e1       	ldi	r24, 0x11	; 17
    e168:	80 93 57 00 	sts	0x0057, r24
    e16c:	e8 95       	spm
 
    /* Re-enable interrupts (if they were ever enabled). */
    SREG = sreg;
    e16e:	1f bf       	out	0x3f, r17	; 63
}
    e170:	df 91       	pop	r29
    e172:	cf 91       	pop	r28
    e174:	1f 91       	pop	r17
    e176:	0f 91       	pop	r16
    e178:	08 95       	ret

0000e17a <fileParser_resetCortex>:
void fileParser_resetCortex()
{
	//set port low

	//pin is output
	CORTEX_RESET_DDR |= (1<<CORTEX_RESET_PIN);
    e17a:	57 9a       	sbi	0x0a, 7	; 10
	//signal low
	CORTEX_RESET_PORT &= ~(1<<CORTEX_RESET_PIN);
    e17c:	5f 98       	cbi	0x0b, 7	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    e17e:	8f e7       	ldi	r24, 0x7F	; 127
    e180:	94 e8       	ldi	r25, 0x84	; 132
    e182:	ae e1       	ldi	r26, 0x1E	; 30
    e184:	81 50       	subi	r24, 0x01	; 1
    e186:	90 40       	sbci	r25, 0x00	; 0
    e188:	a0 40       	sbci	r26, 0x00	; 0
    e18a:	e1 f7       	brne	.-8      	; 0xe184 <fileParser_resetCortex+0xa>
    e18c:	00 c0       	rjmp	.+0      	; 0xe18e <fileParser_resetCortex+0x14>
    e18e:	00 00       	nop
	_delay_ms(500);
	
	//set port high (input)
	//as input
	CORTEX_RESET_DDR &= ~(1<<CORTEX_RESET_PIN);
    e190:	57 98       	cbi	0x0a, 7	; 10
	//no pull up
	CORTEX_RESET_PORT &= ~(1<<CORTEX_RESET_PIN);
    e192:	5f 98       	cbi	0x0b, 7	; 11
    e194:	8f e3       	ldi	r24, 0x3F	; 63
    e196:	9d e0       	ldi	r25, 0x0D	; 13
    e198:	a3 e0       	ldi	r26, 0x03	; 3
    e19a:	81 50       	subi	r24, 0x01	; 1
    e19c:	90 40       	sbci	r25, 0x00	; 0
    e19e:	a0 40       	sbci	r26, 0x00	; 0
    e1a0:	e1 f7       	brne	.-8      	; 0xe19a <fileParser_resetCortex+0x20>
    e1a2:	00 c0       	rjmp	.+0      	; 0xe1a4 <fileParser_resetCortex+0x2a>
    e1a4:	00 00       	nop
	_delay_ms(50);
	
};
    e1a6:	08 95       	ret

0000e1a8 <fileParser_parseNextBlock>:

//------------------------------------------------------------------------

uint8_t fileParser_parseNextBlock(unsigned long filesize)
{
    e1a8:	a0 e0       	ldi	r26, 0x00	; 0
    e1aa:	b0 e0       	ldi	r27, 0x00	; 0
    e1ac:	e9 ed       	ldi	r30, 0xD9	; 217
    e1ae:	f0 e7       	ldi	r31, 0x70	; 112
    e1b0:	95 c6       	rjmp	.+3370   	; 0xeedc <__prologue_saves__+0x14>
    e1b2:	7b 01       	movw	r14, r22
    e1b4:	8c 01       	movw	r16, r24

	switch(fileParser_parseState)
    e1b6:	80 91 94 01 	lds	r24, 0x0194
    e1ba:	81 30       	cpi	r24, 0x01	; 1
    e1bc:	39 f0       	breq	.+14     	; 0xe1cc <fileParser_parseNextBlock+0x24>
    e1be:	81 30       	cpi	r24, 0x01	; 1
    e1c0:	08 f4       	brcc	.+2      	; 0xe1c4 <fileParser_parseNextBlock+0x1c>
    e1c2:	58 c0       	rjmp	.+176    	; 0xe274 <fileParser_parseNextBlock+0xcc>
    e1c4:	82 30       	cpi	r24, 0x02	; 2
    e1c6:	09 f0       	breq	.+2      	; 0xe1ca <fileParser_parseNextBlock+0x22>
    e1c8:	b0 c1       	rjmp	.+864    	; 0xe52a <fileParser_parseNextBlock+0x382>
    e1ca:	09 c1       	rjmp	.+530    	; 0xe3de <fileParser_parseNextBlock+0x236>
				
			//program data into flash (512 bytes data to 4 pages a 128 bytes -> mega32 SPM_PAGESIZE = 128
			//program data into flash (512 bytes data to 2 pages a 256 bytes -> mega644 SPM_PAGESIZE = 256
			
			
			for(int i=0; (i<(512/SPM_PAGESIZE)) && (fileParser_bytesRead < (infoHeader.avrCodeSize +  512)); i++ )
    e1cc:	20 91 8e 01 	lds	r18, 0x018E
    e1d0:	30 91 8f 01 	lds	r19, 0x018F
    e1d4:	40 91 90 01 	lds	r20, 0x0190
    e1d8:	50 91 91 01 	lds	r21, 0x0191
    e1dc:	80 91 9f 01 	lds	r24, 0x019F
    e1e0:	90 91 a0 01 	lds	r25, 0x01A0
    e1e4:	80 50       	subi	r24, 0x00	; 0
    e1e6:	9e 4f       	sbci	r25, 0xFE	; 254
    e1e8:	a0 e0       	ldi	r26, 0x00	; 0
    e1ea:	b0 e0       	ldi	r27, 0x00	; 0
    e1ec:	28 17       	cp	r18, r24
    e1ee:	39 07       	cpc	r19, r25
    e1f0:	4a 07       	cpc	r20, r26
    e1f2:	5b 07       	cpc	r21, r27
    e1f4:	08 f0       	brcs	.+2      	; 0xe1f8 <fileParser_parseNextBlock+0x50>
    e1f6:	b0 c0       	rjmp	.+352    	; 0xe358 <fileParser_parseNextBlock+0x1b0>
			{
				boot_program_page(fileParser_pagesWritten,(uint8_t *)&sd_buffer[0+i*SPM_PAGESIZE]);
    e1f8:	60 91 92 01 	lds	r22, 0x0192
    e1fc:	70 91 93 01 	lds	r23, 0x0193
    e200:	80 e0       	ldi	r24, 0x00	; 0
    e202:	90 e0       	ldi	r25, 0x00	; 0
    e204:	45 ed       	ldi	r20, 0xD5	; 213
    e206:	51 e0       	ldi	r21, 0x01	; 1
    e208:	7e df       	rcall	.-260    	; 0xe106 <boot_program_page>
				fileParser_bytesRead += SPM_PAGESIZE;
    e20a:	80 91 8e 01 	lds	r24, 0x018E
    e20e:	90 91 8f 01 	lds	r25, 0x018F
    e212:	a0 91 90 01 	lds	r26, 0x0190
    e216:	b0 91 91 01 	lds	r27, 0x0191
    e21a:	80 50       	subi	r24, 0x00	; 0
    e21c:	9f 4f       	sbci	r25, 0xFF	; 255
    e21e:	af 4f       	sbci	r26, 0xFF	; 255
    e220:	bf 4f       	sbci	r27, 0xFF	; 255
    e222:	80 93 8e 01 	sts	0x018E, r24
    e226:	90 93 8f 01 	sts	0x018F, r25
    e22a:	a0 93 90 01 	sts	0x0190, r26
    e22e:	b0 93 91 01 	sts	0x0191, r27
				fileParser_pagesWritten+=SPM_PAGESIZE;
    e232:	80 91 92 01 	lds	r24, 0x0192
    e236:	90 91 93 01 	lds	r25, 0x0193
    e23a:	80 50       	subi	r24, 0x00	; 0
    e23c:	9f 4f       	sbci	r25, 0xFF	; 255
    e23e:	90 93 93 01 	sts	0x0193, r25
    e242:	80 93 92 01 	sts	0x0192, r24
				
			//program data into flash (512 bytes data to 4 pages a 128 bytes -> mega32 SPM_PAGESIZE = 128
			//program data into flash (512 bytes data to 2 pages a 256 bytes -> mega644 SPM_PAGESIZE = 256
			
			
			for(int i=0; (i<(512/SPM_PAGESIZE)) && (fileParser_bytesRead < (infoHeader.avrCodeSize +  512)); i++ )
    e246:	20 91 8e 01 	lds	r18, 0x018E
    e24a:	30 91 8f 01 	lds	r19, 0x018F
    e24e:	40 91 90 01 	lds	r20, 0x0190
    e252:	50 91 91 01 	lds	r21, 0x0191
    e256:	80 91 9f 01 	lds	r24, 0x019F
    e25a:	90 91 a0 01 	lds	r25, 0x01A0
    e25e:	80 50       	subi	r24, 0x00	; 0
    e260:	9e 4f       	sbci	r25, 0xFE	; 254
    e262:	a0 e0       	ldi	r26, 0x00	; 0
    e264:	b0 e0       	ldi	r27, 0x00	; 0
    e266:	28 17       	cp	r18, r24
    e268:	39 07       	cpc	r19, r25
    e26a:	4a 07       	cpc	r20, r26
    e26c:	5b 07       	cpc	r21, r27
    e26e:	08 f4       	brcc	.+2      	; 0xe272 <fileParser_parseNextBlock+0xca>
    e270:	4c c0       	rjmp	.+152    	; 0xe30a <fileParser_parseNextBlock+0x162>
    e272:	72 c0       	rjmp	.+228    	; 0xe358 <fileParser_parseNextBlock+0x1b0>
	{
		case INFO_HEADER:
		{
			//--- read info header ---
			struct InfoHeader *tmpHeader = (struct InfoHeader *) &sd_buffer[0];
			infoHeader = *tmpHeader;
    e274:	ab e9       	ldi	r26, 0x9B	; 155
    e276:	b1 e0       	ldi	r27, 0x01	; 1
    e278:	e5 ed       	ldi	r30, 0xD5	; 213
    e27a:	f1 e0       	ldi	r31, 0x01	; 1
    e27c:	8a e0       	ldi	r24, 0x0A	; 10
    e27e:	01 90       	ld	r0, Z+
    e280:	0d 92       	st	X+, r0
    e282:	81 50       	subi	r24, 0x01	; 1
    e284:	e1 f7       	brne	.-8      	; 0xe27e <fileParser_parseNextBlock+0xd6>
	
			if(	(infoHeader.headerId[0] != 'S') ||
    e286:	80 91 9b 01 	lds	r24, 0x019B
    e28a:	83 35       	cpi	r24, 0x53	; 83
    e28c:	61 f4       	brne	.+24     	; 0xe2a6 <fileParser_parseNextBlock+0xfe>
    e28e:	80 91 9c 01 	lds	r24, 0x019C
    e292:	80 35       	cpi	r24, 0x50	; 80
    e294:	41 f4       	brne	.+16     	; 0xe2a6 <fileParser_parseNextBlock+0xfe>
				(infoHeader.headerId[1] != 'P') ||
    e296:	80 91 9d 01 	lds	r24, 0x019D
    e29a:	86 34       	cpi	r24, 0x46	; 70
    e29c:	21 f4       	brne	.+8      	; 0xe2a6 <fileParser_parseNextBlock+0xfe>
				(infoHeader.headerId[2] != 'F') ||
    e29e:	80 91 9e 01 	lds	r24, 0x019E
    e2a2:	89 34       	cpi	r24, 0x49	; 73
    e2a4:	31 f0       	breq	.+12     	; 0xe2b2 <fileParser_parseNextBlock+0x10a>
				(infoHeader.headerId[3] != 'I')
			)
			{
				//header not right -> abort
				
				lcd_clear();
    e2a6:	b0 d1       	rcall	.+864    	; 0xe608 <lcd_clear>
				lcd_home();
    e2a8:	b8 d1       	rcall	.+880    	; 0xe61a <lcd_home>
				lcd_string("hd err");
    e2aa:	80 e0       	ldi	r24, 0x00	; 0
    e2ac:	91 e0       	ldi	r25, 0x01	; 1
    e2ae:	d3 d1       	rcall	.+934    	; 0xe656 <lcd_string>
    e2b0:	ff cf       	rjmp	.-2      	; 0xe2b0 <fileParser_parseNextBlock+0x108>
		//	uint16_t test = infoHeader.avrCodeSize;
		//	lcd_string(utoa(test,text,10));
		//	_delay_ms(1500);
			
		
			fileParser_bytesRead += 512;
    e2b2:	80 91 8e 01 	lds	r24, 0x018E
    e2b6:	90 91 8f 01 	lds	r25, 0x018F
    e2ba:	a0 91 90 01 	lds	r26, 0x0190
    e2be:	b0 91 91 01 	lds	r27, 0x0191
    e2c2:	80 50       	subi	r24, 0x00	; 0
    e2c4:	9e 4f       	sbci	r25, 0xFE	; 254
    e2c6:	af 4f       	sbci	r26, 0xFF	; 255
    e2c8:	bf 4f       	sbci	r27, 0xFF	; 255
    e2ca:	80 93 8e 01 	sts	0x018E, r24
    e2ce:	90 93 8f 01 	sts	0x018F, r25
    e2d2:	a0 93 90 01 	sts	0x0190, r26
    e2d6:	b0 93 91 01 	sts	0x0191, r27
			
			if ((fileParser_bytesRead) >= filesize )
    e2da:	80 91 8e 01 	lds	r24, 0x018E
    e2de:	90 91 8f 01 	lds	r25, 0x018F
    e2e2:	a0 91 90 01 	lds	r26, 0x0190
    e2e6:	b0 91 91 01 	lds	r27, 0x0191
    e2ea:	8e 15       	cp	r24, r14
    e2ec:	9f 05       	cpc	r25, r15
    e2ee:	a0 07       	cpc	r26, r16
    e2f0:	b1 07       	cpc	r27, r17
    e2f2:	38 f0       	brcs	.+14     	; 0xe302 <fileParser_parseNextBlock+0x15a>
			{
				
				lcd_setcursor(0,2);
    e2f4:	80 e0       	ldi	r24, 0x00	; 0
    e2f6:	62 e0       	ldi	r22, 0x02	; 2
    e2f8:	99 d1       	rcall	.+818    	; 0xe62c <lcd_setcursor>
				lcd_string("end hd");
    e2fa:	87 e0       	ldi	r24, 0x07	; 7
    e2fc:	91 e0       	ldi	r25, 0x01	; 1
    e2fe:	ab d1       	rcall	.+854    	; 0xe656 <lcd_string>
    e300:	ff cf       	rjmp	.-2      	; 0xe300 <fileParser_parseNextBlock+0x158>
				while(1);
				
				 return 0;
			}		
			
			fileParser_parseState = AVR_DATA;
    e302:	81 e0       	ldi	r24, 0x01	; 1
    e304:	80 93 94 01 	sts	0x0194, r24
		}			
		break;
    e308:	11 c1       	rjmp	.+546    	; 0xe52c <fileParser_parseNextBlock+0x384>
			//program data into flash (512 bytes data to 2 pages a 256 bytes -> mega644 SPM_PAGESIZE = 256
			
			
			for(int i=0; (i<(512/SPM_PAGESIZE)) && (fileParser_bytesRead < (infoHeader.avrCodeSize +  512)); i++ )
			{
				boot_program_page(fileParser_pagesWritten,(uint8_t *)&sd_buffer[0+i*SPM_PAGESIZE]);
    e30a:	60 91 92 01 	lds	r22, 0x0192
    e30e:	70 91 93 01 	lds	r23, 0x0193
    e312:	80 e0       	ldi	r24, 0x00	; 0
    e314:	90 e0       	ldi	r25, 0x00	; 0
    e316:	45 ed       	ldi	r20, 0xD5	; 213
    e318:	52 e0       	ldi	r21, 0x02	; 2
    e31a:	f5 de       	rcall	.-534    	; 0xe106 <boot_program_page>
				fileParser_bytesRead += SPM_PAGESIZE;
    e31c:	80 91 8e 01 	lds	r24, 0x018E
    e320:	90 91 8f 01 	lds	r25, 0x018F
    e324:	a0 91 90 01 	lds	r26, 0x0190
    e328:	b0 91 91 01 	lds	r27, 0x0191
    e32c:	80 50       	subi	r24, 0x00	; 0
    e32e:	9f 4f       	sbci	r25, 0xFF	; 255
    e330:	af 4f       	sbci	r26, 0xFF	; 255
    e332:	bf 4f       	sbci	r27, 0xFF	; 255
    e334:	80 93 8e 01 	sts	0x018E, r24
    e338:	90 93 8f 01 	sts	0x018F, r25
    e33c:	a0 93 90 01 	sts	0x0190, r26
    e340:	b0 93 91 01 	sts	0x0191, r27
				fileParser_pagesWritten+=SPM_PAGESIZE;
    e344:	80 91 92 01 	lds	r24, 0x0192
    e348:	90 91 93 01 	lds	r25, 0x0193
    e34c:	80 50       	subi	r24, 0x00	; 0
    e34e:	9f 4f       	sbci	r25, 0xFF	; 255
    e350:	90 93 93 01 	sts	0x0193, r25
    e354:	80 93 92 01 	sts	0x0192, r24
			boot_program_page(fileParser_pagesWritten++,&sd_buffer[384]);
			*/
				
			//increment the byte counter
			//fileParser_bytesRead += 512
			if ((fileParser_bytesRead) >= filesize )
    e358:	80 91 8e 01 	lds	r24, 0x018E
    e35c:	90 91 8f 01 	lds	r25, 0x018F
    e360:	a0 91 90 01 	lds	r26, 0x0190
    e364:	b0 91 91 01 	lds	r27, 0x0191
    e368:	8e 15       	cp	r24, r14
    e36a:	9f 05       	cpc	r25, r15
    e36c:	a0 07       	cpc	r26, r16
    e36e:	b1 07       	cpc	r27, r17
    e370:	08 f0       	brcs	.+2      	; 0xe374 <fileParser_parseNextBlock+0x1cc>
    e372:	d9 c0       	rjmp	.+434    	; 0xe526 <fileParser_parseNextBlock+0x37e>
			//	while(1);
				 return 0;
			}				 
			
			//check if AVR code end is reached
			if(fileParser_bytesRead >= (infoHeader.avrCodeSize +  512) )
    e374:	20 91 8e 01 	lds	r18, 0x018E
    e378:	30 91 8f 01 	lds	r19, 0x018F
    e37c:	40 91 90 01 	lds	r20, 0x0190
    e380:	50 91 91 01 	lds	r21, 0x0191
    e384:	80 91 9f 01 	lds	r24, 0x019F
    e388:	90 91 a0 01 	lds	r25, 0x01A0
    e38c:	80 50       	subi	r24, 0x00	; 0
    e38e:	9e 4f       	sbci	r25, 0xFE	; 254
    e390:	a0 e0       	ldi	r26, 0x00	; 0
    e392:	b0 e0       	ldi	r27, 0x00	; 0
    e394:	28 17       	cp	r18, r24
    e396:	39 07       	cpc	r19, r25
    e398:	4a 07       	cpc	r20, r26
    e39a:	5b 07       	cpc	r21, r27
    e39c:	08 f4       	brcc	.+2      	; 0xe3a0 <fileParser_parseNextBlock+0x1f8>
    e39e:	c5 c0       	rjmp	.+394    	; 0xe52a <fileParser_parseNextBlock+0x382>
			{
				
				
				//reset cortex chip
				//lcd_clear();
				lcd_home();
    e3a0:	3c d1       	rcall	.+632    	; 0xe61a <lcd_home>
				lcd_string("updating...(1/2)");
    e3a2:	8e e0       	ldi	r24, 0x0E	; 14
    e3a4:	91 e0       	ldi	r25, 0x01	; 1
    e3a6:	57 d1       	rcall	.+686    	; 0xe656 <lcd_string>
				
				fileParser_resetCortex();
    e3a8:	e8 de       	rcall	.-560    	; 0xe17a <fileParser_resetCortex>
				//initialize the cortex bootloader
				//try 10 times to give the cortex some time to boot and answer
				int i=0;
				for(;;)
				{
					uart_tx(INIT_BOOTLOADER);
    e3aa:	81 e0       	ldi	r24, 0x01	; 1
    e3ac:	2a d5       	rcall	.+2644   	; 0xee02 <uart_tx>
    e3ae:	8f ef       	ldi	r24, 0xFF	; 255
    e3b0:	98 e0       	ldi	r25, 0x08	; 8
    e3b2:	ad e3       	ldi	r26, 0x3D	; 61
    e3b4:	81 50       	subi	r24, 0x01	; 1
    e3b6:	90 40       	sbci	r25, 0x00	; 0
    e3b8:	a0 40       	sbci	r26, 0x00	; 0
    e3ba:	e1 f7       	brne	.-8      	; 0xe3b4 <fileParser_parseNextBlock+0x20c>
    e3bc:	00 c0       	rjmp	.+0      	; 0xe3be <fileParser_parseNextBlock+0x216>
    e3be:	00 00       	nop
					_delay_ms(1000);
					//if received data is available
#ifdef MEGA32					
					if( (UCSRA & (1<<RXC)) )
#else
					if( (UCSR0A & (1<<RXC0)) )
    e3c0:	80 91 c0 00 	lds	r24, 0x00C0
    e3c4:	87 ff       	sbrs	r24, 7
    e3c6:	f1 cf       	rjmp	.-30     	; 0xe3aa <fileParser_parseNextBlock+0x202>
#endif
					{
			//			lcd_setcursor(0,2);
			//	lcd_string("wait ack");
						uint8_t data = uart_rxWait();	
    e3c8:	15 d5       	rcall	.+2602   	; 0xedf4 <uart_rxWait>
						
						
						if(data == ACK)
    e3ca:	84 30       	cpi	r24, 0x04	; 4
    e3cc:	71 f7       	brne	.-36     	; 0xe3aa <fileParser_parseNextBlock+0x202>
					while(1);
					return 0;
				}
				
				//now we can send the cortex bootloader commands and data
				fileParser_parseState = CORTEX_DATA;
    e3ce:	82 e0       	ldi	r24, 0x02	; 2
    e3d0:	80 93 94 01 	sts	0x0194, r24
				
				
				
				//give the cortex time to erase the flash
			//	_delay_ms(2000); //ack is send after flash delete
				lcd_home();
    e3d4:	22 d1       	rcall	.+580    	; 0xe61a <lcd_home>
				lcd_string("updating...(2/2)");
    e3d6:	8f e1       	ldi	r24, 0x1F	; 31
    e3d8:	91 e0       	ldi	r25, 0x01	; 1
    e3da:	3d d1       	rcall	.+634    	; 0xe656 <lcd_string>
    e3dc:	a6 c0       	rjmp	.+332    	; 0xe52a <fileParser_parseNextBlock+0x382>
//------------------------------------------------------------------------

uint8_t fileParser_parseNextBlock(unsigned long filesize)
{

	switch(fileParser_parseState)
    e3de:	c0 e0       	ldi	r28, 0x00	; 0
    e3e0:	d0 e0       	ldi	r29, 0x00	; 0
				
				uint16_t crc;
			
				// send the address
				
				crc = calcCrc(WRITE_ADDRESS,(uint8_t*)&addressCounter);
    e3e2:	83 e0       	ldi	r24, 0x03	; 3
    e3e4:	65 e9       	ldi	r22, 0x95	; 149
    e3e6:	71 e0       	ldi	r23, 0x01	; 1
    e3e8:	7b de       	rcall	.-778    	; 0xe0e0 <calcCrc>
    e3ea:	d8 2e       	mov	r13, r24
    e3ec:	c9 2e       	mov	r12, r25
				//send next address packet until ACK received
				do 
				{
					uart_tx(WRITE_ADDRESS);
    e3ee:	83 e0       	ldi	r24, 0x03	; 3
    e3f0:	08 d5       	rcall	.+2576   	; 0xee02 <uart_tx>
					//lcd_home();
					//lcd_string("cmd");
					uart_tx(addressCounter>>24);
    e3f2:	80 91 95 01 	lds	r24, 0x0195
    e3f6:	90 91 96 01 	lds	r25, 0x0196
    e3fa:	a0 91 97 01 	lds	r26, 0x0197
    e3fe:	b0 91 98 01 	lds	r27, 0x0198
    e402:	8b 2f       	mov	r24, r27
    e404:	fe d4       	rcall	.+2556   	; 0xee02 <uart_tx>
			//		lcd_home();
		//	lcd_string("1");
					uart_tx(addressCounter>>16);
    e406:	60 91 95 01 	lds	r22, 0x0195
    e40a:	70 91 96 01 	lds	r23, 0x0196
    e40e:	80 91 97 01 	lds	r24, 0x0197
    e412:	90 91 98 01 	lds	r25, 0x0198
    e416:	f5 d4       	rcall	.+2538   	; 0xee02 <uart_tx>
		//			lcd_home();
		//	lcd_string("2");
					uart_tx(addressCounter>>8);
    e418:	20 91 95 01 	lds	r18, 0x0195
    e41c:	30 91 96 01 	lds	r19, 0x0196
    e420:	40 91 97 01 	lds	r20, 0x0197
    e424:	50 91 98 01 	lds	r21, 0x0198
    e428:	83 2f       	mov	r24, r19
    e42a:	eb d4       	rcall	.+2518   	; 0xee02 <uart_tx>
		//			lcd_home();
		//	lcd_string("3");
					uart_tx(addressCounter);
    e42c:	20 91 95 01 	lds	r18, 0x0195
    e430:	30 91 96 01 	lds	r19, 0x0196
    e434:	40 91 97 01 	lds	r20, 0x0197
    e438:	50 91 98 01 	lds	r21, 0x0198
    e43c:	82 2f       	mov	r24, r18
    e43e:	e1 d4       	rcall	.+2498   	; 0xee02 <uart_tx>
		//			lcd_home();
		//	lcd_string("4");
					//send calculated CRC
					uart_tx(crc>>8);
    e440:	8c 2d       	mov	r24, r12
    e442:	df d4       	rcall	.+2494   	; 0xee02 <uart_tx>
		//			lcd_home();
		//	lcd_string("c1");
					uart_tx(crc&0xff);
    e444:	8d 2d       	mov	r24, r13
    e446:	dd d4       	rcall	.+2490   	; 0xee02 <uart_tx>
		//			lcd_home();
		//	lcd_string("c2");
				} 
				while (uart_checkAck()!=ACK);	
    e448:	e3 d4       	rcall	.+2502   	; 0xee10 <uart_checkAck>
    e44a:	84 30       	cpi	r24, 0x04	; 4
    e44c:	81 f6       	brne	.-96     	; 0xe3ee <fileParser_parseNextBlock+0x246>
				
			
				//calc crc for data block
				crc = calcCrc(WRITE_DATA,&sd_buffer[i]);
    e44e:	be 01       	movw	r22, r28
    e450:	6b 52       	subi	r22, 0x2B	; 43
    e452:	7e 4f       	sbci	r23, 0xFE	; 254
    e454:	82 e0       	ldi	r24, 0x02	; 2
    e456:	44 de       	rcall	.-888    	; 0xe0e0 <calcCrc>
    e458:	d8 2e       	mov	r13, r24
    e45a:	c9 2e       	mov	r12, r25
				//send next data packet until ACK received
				do 
				{
					//send command
					uart_tx(WRITE_DATA);
    e45c:	82 e0       	ldi	r24, 0x02	; 2
    e45e:	d1 d4       	rcall	.+2466   	; 0xee02 <uart_tx>
					//after the command, send the 4 data bytes
					uart_tx(sd_buffer[i+3]);
    e460:	fe 01       	movw	r30, r28
    e462:	e8 52       	subi	r30, 0x28	; 40
    e464:	fe 4f       	sbci	r31, 0xFE	; 254
    e466:	80 81       	ld	r24, Z
    e468:	cc d4       	rcall	.+2456   	; 0xee02 <uart_tx>
					uart_tx(sd_buffer[i+2]);
    e46a:	fe 01       	movw	r30, r28
    e46c:	e9 52       	subi	r30, 0x29	; 41
    e46e:	fe 4f       	sbci	r31, 0xFE	; 254
    e470:	80 81       	ld	r24, Z
    e472:	c7 d4       	rcall	.+2446   	; 0xee02 <uart_tx>
					uart_tx(sd_buffer[i+1]);
    e474:	fe 01       	movw	r30, r28
    e476:	ea 52       	subi	r30, 0x2A	; 42
    e478:	fe 4f       	sbci	r31, 0xFE	; 254
    e47a:	80 81       	ld	r24, Z
    e47c:	c2 d4       	rcall	.+2436   	; 0xee02 <uart_tx>
					uart_tx(sd_buffer[i]);
    e47e:	fe 01       	movw	r30, r28
    e480:	eb 52       	subi	r30, 0x2B	; 43
    e482:	fe 4f       	sbci	r31, 0xFE	; 254
    e484:	80 81       	ld	r24, Z
    e486:	bd d4       	rcall	.+2426   	; 0xee02 <uart_tx>
					//send calculated CRC
					uart_tx(crc>>8);
    e488:	8c 2d       	mov	r24, r12
    e48a:	bb d4       	rcall	.+2422   	; 0xee02 <uart_tx>
					uart_tx(crc&0xff);
    e48c:	8d 2d       	mov	r24, r13
    e48e:	b9 d4       	rcall	.+2418   	; 0xee02 <uart_tx>
				} 
				while (uart_checkAck()!=ACK);
    e490:	bf d4       	rcall	.+2430   	; 0xee10 <uart_checkAck>
    e492:	84 30       	cpi	r24, 0x04	; 4
    e494:	19 f7       	brne	.-58     	; 0xe45c <fileParser_parseNextBlock+0x2b4>
				
				//transfer succeeded
				addressCounter++;
    e496:	80 91 95 01 	lds	r24, 0x0195
    e49a:	90 91 96 01 	lds	r25, 0x0196
    e49e:	a0 91 97 01 	lds	r26, 0x0197
    e4a2:	b0 91 98 01 	lds	r27, 0x0198
    e4a6:	01 96       	adiw	r24, 0x01	; 1
    e4a8:	a1 1d       	adc	r26, r1
    e4aa:	b1 1d       	adc	r27, r1
    e4ac:	80 93 95 01 	sts	0x0195, r24
    e4b0:	90 93 96 01 	sts	0x0196, r25
    e4b4:	a0 93 97 01 	sts	0x0197, r26
    e4b8:	b0 93 98 01 	sts	0x0198, r27
			//--- read cortex code ---
			
			//we have 512 bytes of data
			//data is 32 bit unsigned int
			//we increment with 4 because in each run we send out 4 bytes => 1 32 bit int message
			for(int i=0;i<512;i+=4)
    e4bc:	24 96       	adiw	r28, 0x04	; 4
    e4be:	92 e0       	ldi	r25, 0x02	; 2
    e4c0:	c0 30       	cpi	r28, 0x00	; 0
    e4c2:	d9 07       	cpc	r29, r25
    e4c4:	09 f0       	breq	.+2      	; 0xe4c8 <fileParser_parseNextBlock+0x320>
    e4c6:	8d cf       	rjmp	.-230    	; 0xe3e2 <fileParser_parseNextBlock+0x23a>
			char text[10];
			lcd_string(utoa(addressCounter,text,10));
			*/
			
				
			fileParser_bytesRead+=512;
    e4c8:	80 91 8e 01 	lds	r24, 0x018E
    e4cc:	90 91 8f 01 	lds	r25, 0x018F
    e4d0:	a0 91 90 01 	lds	r26, 0x0190
    e4d4:	b0 91 91 01 	lds	r27, 0x0191
    e4d8:	80 50       	subi	r24, 0x00	; 0
    e4da:	9e 4f       	sbci	r25, 0xFE	; 254
    e4dc:	af 4f       	sbci	r26, 0xFF	; 255
    e4de:	bf 4f       	sbci	r27, 0xFF	; 255
    e4e0:	80 93 8e 01 	sts	0x018E, r24
    e4e4:	90 93 8f 01 	sts	0x018F, r25
    e4e8:	a0 93 90 01 	sts	0x0190, r26
    e4ec:	b0 93 91 01 	sts	0x0191, r27
			//send cortex bootloader data
				
			if ((fileParser_bytesRead) >= filesize )
    e4f0:	80 91 8e 01 	lds	r24, 0x018E
    e4f4:	90 91 8f 01 	lds	r25, 0x018F
    e4f8:	a0 91 90 01 	lds	r26, 0x0190
    e4fc:	b0 91 91 01 	lds	r27, 0x0191
    e500:	8e 15       	cp	r24, r14
    e502:	9f 05       	cpc	r25, r15
    e504:	a0 07       	cpc	r26, r16
    e506:	b1 07       	cpc	r27, r17
    e508:	80 f0       	brcs	.+32     	; 0xe52a <fileParser_parseNextBlock+0x382>
			{
				lcd_clear();
    e50a:	7e d0       	rcall	.+252    	; 0xe608 <lcd_clear>
				lcd_home();
    e50c:	86 d0       	rcall	.+268    	; 0xe61a <lcd_home>
				lcd_string("success!");
    e50e:	80 e3       	ldi	r24, 0x30	; 48
    e510:	91 e0       	ldi	r25, 0x01	; 1
    e512:	a1 d0       	rcall	.+322    	; 0xe656 <lcd_string>
				lcd_setcursor(0,2);
    e514:	80 e0       	ldi	r24, 0x00	; 0
    e516:	62 e0       	ldi	r22, 0x02	; 2
    e518:	89 d0       	rcall	.+274    	; 0xe62c <lcd_setcursor>
				lcd_string("please reboot...");
    e51a:	89 e3       	ldi	r24, 0x39	; 57
    e51c:	91 e0       	ldi	r25, 0x01	; 1
    e51e:	9b d0       	rcall	.+310    	; 0xe656 <lcd_string>
				uart_tx(END_BOOTLOADER);
    e520:	86 e0       	ldi	r24, 0x06	; 6
    e522:	6f d4       	rcall	.+2270   	; 0xee02 <uart_tx>
    e524:	ff cf       	rjmp	.-2      	; 0xe524 <fileParser_parseNextBlock+0x37c>
			if ((fileParser_bytesRead) >= filesize )
			{
			//	lcd_setcursor(0,2);
			//	lcd_string("end avr");
			//	while(1);
				 return 0;
    e526:	80 e0       	ldi	r24, 0x00	; 0
    e528:	01 c0       	rjmp	.+2      	; 0xe52c <fileParser_parseNextBlock+0x384>
				 return 0;
			}		
		break;
	}

	return 1;
    e52a:	81 e0       	ldi	r24, 0x01	; 1
    e52c:	cd b7       	in	r28, 0x3d	; 61
    e52e:	de b7       	in	r29, 0x3e	; 62
    e530:	e8 e0       	ldi	r30, 0x08	; 8
    e532:	f0 c4       	rjmp	.+2528   	; 0xef14 <__epilogue_restores__+0x14>

0000e534 <lcd_enable>:
#include <avr/pgmspace.h>
////////////////////////////////////////////////////////////////////////////////
// Erzeugt einen Enable-Puls
static void lcd_enable( void )
{
    LCD_RSEN_PORT |= (1<<LCD_EN);     // Enable auf 1 setzen
    e534:	43 9a       	sbi	0x08, 3	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    e536:	85 e8       	ldi	r24, 0x85	; 133
    e538:	8a 95       	dec	r24
    e53a:	f1 f7       	brne	.-4      	; 0xe538 <lcd_enable+0x4>
    e53c:	00 00       	nop
    _delay_us( LCD_ENABLE_US );  // kurze Pause
    LCD_RSEN_PORT &= ~(1<<LCD_EN);    // Enable auf 0 setzen
    e53e:	43 98       	cbi	0x08, 3	; 8
}
    e540:	08 95       	ret

0000e542 <lcd_out>:
// Sendet eine 4-bit Ausgabeoperation an das LCD
static void lcd_out( uint8_t data )
{
    data &= 0xF0;                       // obere 4 Bit maskieren
 
    LCD_PORT &= ~(0xF0>>(4-LCD_DB));    // Maske löschen
    e542:	95 b1       	in	r25, 0x05	; 5
    e544:	90 7f       	andi	r25, 0xF0	; 240
    e546:	95 b9       	out	0x05, r25	; 5
    LCD_PORT |= (data>>(4-LCD_DB));     // Bits setzen
    e548:	95 b1       	in	r25, 0x05	; 5
    e54a:	82 95       	swap	r24
    e54c:	8f 70       	andi	r24, 0x0F	; 15
    e54e:	89 2b       	or	r24, r25
    e550:	85 b9       	out	0x05, r24	; 5
    lcd_enable();
}
    e552:	f0 cf       	rjmp	.-32     	; 0xe534 <lcd_enable>

0000e554 <lcd_init>:
    // verwendete Pins auf Ausgang schalten
    uint8_t pins = (0x0F << LCD_DB);           // 4 Datenleitungen
	
	uint8_t rsen_pins = (1<<LCD_RS) |                // R/S Leitung
						(1<<LCD_EN);                 // Enable Leitung
    LCD_DDR |= pins;
    e554:	84 b1       	in	r24, 0x04	; 4
    e556:	8f 60       	ori	r24, 0x0F	; 15
    e558:	84 b9       	out	0x04, r24	; 4
	
	LCD_RSEN_DDR |= rsen_pins;
    e55a:	87 b1       	in	r24, 0x07	; 7
    e55c:	88 61       	ori	r24, 0x18	; 24
    e55e:	87 b9       	out	0x07, r24	; 7
 
    // initial alle Ausgänge auf Null
    LCD_PORT &= ~pins;
    e560:	85 b1       	in	r24, 0x05	; 5
    e562:	80 7f       	andi	r24, 0xF0	; 240
    e564:	85 b9       	out	0x05, r24	; 5
	
	LCD_RSEN_PORT &= ~rsen_pins;
    e566:	88 b1       	in	r24, 0x08	; 8
    e568:	87 7e       	andi	r24, 0xE7	; 231
    e56a:	88 b9       	out	0x08, r24	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    e56c:	8f e5       	ldi	r24, 0x5F	; 95
    e56e:	9a ee       	ldi	r25, 0xEA	; 234
    e570:	a0 e0       	ldi	r26, 0x00	; 0
    e572:	81 50       	subi	r24, 0x01	; 1
    e574:	90 40       	sbci	r25, 0x00	; 0
    e576:	a0 40       	sbci	r26, 0x00	; 0
    e578:	e1 f7       	brne	.-8      	; 0xe572 <lcd_init+0x1e>
    e57a:	00 c0       	rjmp	.+0      	; 0xe57c <lcd_init+0x28>
    e57c:	00 00       	nop
 
    // warten auf die Bereitschaft des LCD
    _delay_ms( LCD_BOOTUP_MS );
    
    // Soft-Reset muss 3mal hintereinander gesendet werden zur Initialisierung
    lcd_out( LCD_SOFT_RESET );
    e57e:	80 e3       	ldi	r24, 0x30	; 48
    e580:	e0 df       	rcall	.-64     	; 0xe542 <lcd_out>
    e582:	a7 ea       	ldi	r26, 0xA7	; 167
    e584:	b1 e6       	ldi	r27, 0x61	; 97
    e586:	11 97       	sbiw	r26, 0x01	; 1
    e588:	f1 f7       	brne	.-4      	; 0xe586 <lcd_init+0x32>
    e58a:	00 c0       	rjmp	.+0      	; 0xe58c <lcd_init+0x38>
    e58c:	00 00       	nop
    _delay_ms( LCD_SOFT_RESET_MS1 );
 
    lcd_enable();
    e58e:	d2 df       	rcall	.-92     	; 0xe534 <lcd_enable>
    e590:	87 e8       	ldi	r24, 0x87	; 135
    e592:	93 e1       	ldi	r25, 0x13	; 19
    e594:	01 97       	sbiw	r24, 0x01	; 1
    e596:	f1 f7       	brne	.-4      	; 0xe594 <lcd_init+0x40>
    e598:	00 c0       	rjmp	.+0      	; 0xe59a <lcd_init+0x46>
    e59a:	00 00       	nop
    _delay_ms( LCD_SOFT_RESET_MS2 );
 
    lcd_enable();
    e59c:	cb df       	rcall	.-106    	; 0xe534 <lcd_enable>
    e59e:	a7 e8       	ldi	r26, 0x87	; 135
    e5a0:	b3 e1       	ldi	r27, 0x13	; 19
    e5a2:	11 97       	sbiw	r26, 0x01	; 1
    e5a4:	f1 f7       	brne	.-4      	; 0xe5a2 <lcd_init+0x4e>
    e5a6:	00 c0       	rjmp	.+0      	; 0xe5a8 <lcd_init+0x54>
    e5a8:	00 00       	nop
    _delay_ms( LCD_SOFT_RESET_MS3 );
 
    // 4-bit Modus aktivieren 
    lcd_out( LCD_SET_FUNCTION |
    e5aa:	80 e2       	ldi	r24, 0x20	; 32
    e5ac:	ca df       	rcall	.-108    	; 0xe542 <lcd_out>
    e5ae:	87 ea       	ldi	r24, 0xA7	; 167
    e5b0:	91 e6       	ldi	r25, 0x61	; 97
    e5b2:	01 97       	sbiw	r24, 0x01	; 1
    e5b4:	f1 f7       	brne	.-4      	; 0xe5b2 <lcd_init+0x5e>
    e5b6:	00 c0       	rjmp	.+0      	; 0xe5b8 <lcd_init+0x64>
    e5b8:	00 00       	nop
             LCD_FUNCTION_4BIT );
    _delay_ms( LCD_SET_4BITMODE_MS );
 
    // 4-bit Modus / 2 Zeilen / 5x7
    lcd_command( LCD_SET_FUNCTION |
    e5ba:	88 e2       	ldi	r24, 0x28	; 40
    e5bc:	15 d0       	rcall	.+42     	; 0xe5e8 <lcd_command>
                 LCD_FUNCTION_4BIT |
                 LCD_FUNCTION_2LINE |
                 LCD_FUNCTION_5X7 );
 
    // Display ein / Cursor aus / Blinken aus
    lcd_command( LCD_SET_DISPLAY |
    e5be:	8c e0       	ldi	r24, 0x0C	; 12
    e5c0:	13 d0       	rcall	.+38     	; 0xe5e8 <lcd_command>
                 LCD_DISPLAY_ON |
                 LCD_CURSOR_OFF |
                 LCD_BLINKING_OFF); 
 
    // Cursor inkrement / kein Scrollen
    lcd_command( LCD_SET_ENTRY |
    e5c2:	86 e0       	ldi	r24, 0x06	; 6
    e5c4:	11 d0       	rcall	.+34     	; 0xe5e8 <lcd_command>
                 LCD_ENTRY_INCREASE |
                 LCD_ENTRY_NOSHIFT );
 
    lcd_clear();
}
    e5c6:	20 c0       	rjmp	.+64     	; 0xe608 <lcd_clear>

0000e5c8 <lcd_data>:
  
////////////////////////////////////////////////////////////////////////////////
// Sendet ein Datenbyte an das LCD
void lcd_data( uint8_t data )
{
    e5c8:	1f 93       	push	r17
    e5ca:	18 2f       	mov	r17, r24
    LCD_RSEN_PORT |= (1<<LCD_RS);    // RS auf 1 setzen
    e5cc:	44 9a       	sbi	0x08, 4	; 8
 
    lcd_out( data );            // zuerst die oberen, 
    e5ce:	b9 df       	rcall	.-142    	; 0xe542 <lcd_out>
    lcd_out( data<<4 );         // dann die unteren 4 Bit senden
    e5d0:	81 2f       	mov	r24, r17
    e5d2:	82 95       	swap	r24
    e5d4:	80 7f       	andi	r24, 0xF0	; 240
    e5d6:	b5 df       	rcall	.-150    	; 0xe542 <lcd_out>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    e5d8:	85 ee       	ldi	r24, 0xE5	; 229
    e5da:	90 e0       	ldi	r25, 0x00	; 0
    e5dc:	01 97       	sbiw	r24, 0x01	; 1
    e5de:	f1 f7       	brne	.-4      	; 0xe5dc <lcd_data+0x14>
    e5e0:	00 c0       	rjmp	.+0      	; 0xe5e2 <lcd_data+0x1a>
    e5e2:	00 00       	nop
 
    _delay_us( LCD_WRITEDATA_US );
}
    e5e4:	1f 91       	pop	r17
    e5e6:	08 95       	ret

0000e5e8 <lcd_command>:
 
////////////////////////////////////////////////////////////////////////////////
// Sendet einen Befehl an das LCD
void lcd_command( uint8_t data )
{
    e5e8:	1f 93       	push	r17
    e5ea:	18 2f       	mov	r17, r24
    LCD_RSEN_PORT &= ~(1<<LCD_RS);    // RS auf 0 setzen
    e5ec:	44 98       	cbi	0x08, 4	; 8
 
    lcd_out( data );             // zuerst die oberen, 
    e5ee:	a9 df       	rcall	.-174    	; 0xe542 <lcd_out>
    lcd_out( data<<4 );           // dann die unteren 4 Bit senden
    e5f0:	81 2f       	mov	r24, r17
    e5f2:	82 95       	swap	r24
    e5f4:	80 7f       	andi	r24, 0xF0	; 240
    e5f6:	a5 df       	rcall	.-182    	; 0xe542 <lcd_out>
    e5f8:	81 ed       	ldi	r24, 0xD1	; 209
    e5fa:	90 e0       	ldi	r25, 0x00	; 0
    e5fc:	01 97       	sbiw	r24, 0x01	; 1
    e5fe:	f1 f7       	brne	.-4      	; 0xe5fc <lcd_command+0x14>
    e600:	00 c0       	rjmp	.+0      	; 0xe602 <lcd_command+0x1a>
    e602:	00 00       	nop
 
    _delay_us( LCD_COMMAND_US );
}
    e604:	1f 91       	pop	r17
    e606:	08 95       	ret

0000e608 <lcd_clear>:
 
////////////////////////////////////////////////////////////////////////////////
// Sendet den Befehl zur Löschung des Displays
void lcd_clear( void )
{
    lcd_command( LCD_CLEAR_DISPLAY );
    e608:	81 e0       	ldi	r24, 0x01	; 1
    e60a:	ee df       	rcall	.-36     	; 0xe5e8 <lcd_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    e60c:	8f e0       	ldi	r24, 0x0F	; 15
    e60e:	97 e2       	ldi	r25, 0x27	; 39
    e610:	01 97       	sbiw	r24, 0x01	; 1
    e612:	f1 f7       	brne	.-4      	; 0xe610 <lcd_clear+0x8>
    e614:	00 c0       	rjmp	.+0      	; 0xe616 <lcd_clear+0xe>
    e616:	00 00       	nop
    _delay_ms( LCD_CLEAR_DISPLAY_MS );
}
    e618:	08 95       	ret

0000e61a <lcd_home>:
 
////////////////////////////////////////////////////////////////////////////////
// Sendet den Befehl: Cursor Home
void lcd_home( void )
{
    lcd_command( LCD_CURSOR_HOME );
    e61a:	82 e0       	ldi	r24, 0x02	; 2
    e61c:	e5 df       	rcall	.-54     	; 0xe5e8 <lcd_command>
    e61e:	8f e0       	ldi	r24, 0x0F	; 15
    e620:	97 e2       	ldi	r25, 0x27	; 39
    e622:	01 97       	sbiw	r24, 0x01	; 1
    e624:	f1 f7       	brne	.-4      	; 0xe622 <lcd_home+0x8>
    e626:	00 c0       	rjmp	.+0      	; 0xe628 <lcd_home+0xe>
    e628:	00 00       	nop
    _delay_ms( LCD_CURSOR_HOME_MS );
}
    e62a:	08 95       	ret

0000e62c <lcd_setcursor>:
 
void lcd_setcursor( uint8_t x, uint8_t y )
{
    uint8_t data;
 
    switch (y)
    e62c:	62 30       	cpi	r22, 0x02	; 2
    e62e:	61 f0       	breq	.+24     	; 0xe648 <lcd_setcursor+0x1c>
    e630:	63 30       	cpi	r22, 0x03	; 3
    e632:	18 f4       	brcc	.+6      	; 0xe63a <lcd_setcursor+0xe>
    e634:	61 30       	cpi	r22, 0x01	; 1
    e636:	71 f4       	brne	.+28     	; 0xe654 <lcd_setcursor+0x28>
    e638:	05 c0       	rjmp	.+10     	; 0xe644 <lcd_setcursor+0x18>
    e63a:	63 30       	cpi	r22, 0x03	; 3
    e63c:	39 f0       	breq	.+14     	; 0xe64c <lcd_setcursor+0x20>
    e63e:	64 30       	cpi	r22, 0x04	; 4
    e640:	49 f4       	brne	.+18     	; 0xe654 <lcd_setcursor+0x28>
    e642:	06 c0       	rjmp	.+12     	; 0xe650 <lcd_setcursor+0x24>
    {
        case 1:    // 1. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE1 + x;
    e644:	80 58       	subi	r24, 0x80	; 128
            break;
    e646:	05 c0       	rjmp	.+10     	; 0xe652 <lcd_setcursor+0x26>
 
        case 2:    // 2. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE2 + x;
    e648:	80 54       	subi	r24, 0x40	; 64
            break;
    e64a:	03 c0       	rjmp	.+6      	; 0xe652 <lcd_setcursor+0x26>
 
        case 3:    // 3. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE3 + x;
    e64c:	80 57       	subi	r24, 0x70	; 112
            break;
    e64e:	01 c0       	rjmp	.+2      	; 0xe652 <lcd_setcursor+0x26>
 
        case 4:    // 4. Zeile
            data = LCD_SET_DDADR + LCD_DDADR_LINE4 + x;
    e650:	80 53       	subi	r24, 0x30	; 48
 
        default:
            return;                                   // für den Fall einer falschen Zeile
    }
 
    lcd_command( data );
    e652:	ca cf       	rjmp	.-108    	; 0xe5e8 <lcd_command>
    e654:	08 95       	ret

0000e656 <lcd_string>:
 
////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD
 
void lcd_string( const char *data )
{
    e656:	ef 92       	push	r14
    e658:	ff 92       	push	r15
    e65a:	cf 93       	push	r28
    e65c:	df 93       	push	r29
    e65e:	e8 2e       	mov	r14, r24
    e660:	e7 01       	movw	r28, r14
    e662:	7e 01       	movw	r14, r28
    e664:	f9 2e       	mov	r15, r25
    e666:	e7 01       	movw	r28, r14
    while( *data != '\0' )
    e668:	01 c0       	rjmp	.+2      	; 0xe66c <lcd_string+0x16>
        lcd_data( *data++ );
    e66a:	ae df       	rcall	.-164    	; 0xe5c8 <lcd_data>
////////////////////////////////////////////////////////////////////////////////
// Schreibt einen String auf das LCD
 
void lcd_string( const char *data )
{
    while( *data != '\0' )
    e66c:	89 91       	ld	r24, Y+
    e66e:	88 23       	and	r24, r24
    e670:	e1 f7       	brne	.-8      	; 0xe66a <lcd_string+0x14>
        lcd_data( *data++ );
}
    e672:	df 91       	pop	r29
    e674:	cf 91       	pop	r28
    e676:	ff 90       	pop	r15
    e678:	ef 90       	pop	r14
    e67a:	08 95       	ret

0000e67c <getBootSectorData>:
//parameters like bytesPerSector, sectorsPerCluster etc.
//Arguments: none
//return: none
//***************************************************************************
unsigned char getBootSectorData (void)
{
    e67c:	a0 e0       	ldi	r26, 0x00	; 0
    e67e:	b0 e0       	ldi	r27, 0x00	; 0
    e680:	e3 e4       	ldi	r30, 0x43	; 67
    e682:	f3 e7       	ldi	r31, 0x73	; 115
    e684:	2b c4       	rjmp	.+2134   	; 0xeedc <__prologue_saves__+0x14>
struct BS_Structure *bpb; //mapping the sd_buffer onto the structure
struct MBRinfo_Structure *mbr;
struct partitionInfo_Structure *partition;
unsigned long dataSectors;

unusedSectors = 0;
    e686:	10 92 c7 01 	sts	0x01C7, r1
    e68a:	10 92 c8 01 	sts	0x01C8, r1
    e68e:	10 92 c9 01 	sts	0x01C9, r1
    e692:	10 92 ca 01 	sts	0x01CA, r1

SD_readSingleBlock(0);
    e696:	60 e0       	ldi	r22, 0x00	; 0
    e698:	70 e0       	ldi	r23, 0x00	; 0
    e69a:	cb 01       	movw	r24, r22
    e69c:	5b d3       	rcall	.+1718   	; 0xed54 <SD_readSingleBlock>
bpb = (struct BS_Structure *)sd_buffer;

if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB)   //check if it is boot sector
    e69e:	80 91 d5 01 	lds	r24, 0x01D5
    e6a2:	89 3e       	cpi	r24, 0xE9	; 233
    e6a4:	19 f1       	breq	.+70     	; 0xe6ec <getBootSectorData+0x70>
    e6a6:	8b 3e       	cpi	r24, 0xEB	; 235
    e6a8:	09 f1       	breq	.+66     	; 0xe6ec <getBootSectorData+0x70>
{
  mbr = (struct MBRinfo_Structure *) sd_buffer;       //if it is not boot sector, it must be MBR
  
  if(mbr->signature != 0xaa55) return 1;       //if it is not even MBR then it's not FAT32
    e6aa:	80 91 d3 03 	lds	r24, 0x03D3
    e6ae:	90 91 d4 03 	lds	r25, 0x03D4
    e6b2:	2a ea       	ldi	r18, 0xAA	; 170
    e6b4:	85 35       	cpi	r24, 0x55	; 85
    e6b6:	92 07       	cpc	r25, r18
    e6b8:	09 f0       	breq	.+2      	; 0xe6bc <getBootSectorData+0x40>
    e6ba:	92 c0       	rjmp	.+292    	; 0xe7e0 <getBootSectorData+0x164>
  	
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
    e6bc:	60 91 9b 03 	lds	r22, 0x039B
    e6c0:	70 91 9c 03 	lds	r23, 0x039C
    e6c4:	80 91 9d 03 	lds	r24, 0x039D
    e6c8:	90 91 9e 03 	lds	r25, 0x039E
    e6cc:	60 93 c7 01 	sts	0x01C7, r22
    e6d0:	70 93 c8 01 	sts	0x01C8, r23
    e6d4:	80 93 c9 01 	sts	0x01C9, r24
    e6d8:	90 93 ca 01 	sts	0x01CA, r25
  
  SD_readSingleBlock(partition->firstSector);//read the bpb sector
    e6dc:	3b d3       	rcall	.+1654   	; 0xed54 <SD_readSingleBlock>
  bpb = (struct BS_Structure *)sd_buffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    e6de:	80 91 d5 01 	lds	r24, 0x01D5
    e6e2:	89 3e       	cpi	r24, 0xE9	; 233
    e6e4:	19 f0       	breq	.+6      	; 0xe6ec <getBootSectorData+0x70>
    e6e6:	8b 3e       	cpi	r24, 0xEB	; 235
    e6e8:	09 f0       	breq	.+2      	; 0xe6ec <getBootSectorData+0x70>
    e6ea:	7a c0       	rjmp	.+244    	; 0xe7e0 <getBootSectorData+0x164>
}

bytesPerSector = bpb->bytesPerSector;
    e6ec:	80 91 e0 01 	lds	r24, 0x01E0
    e6f0:	90 91 e1 01 	lds	r25, 0x01E1
    e6f4:	90 93 bc 01 	sts	0x01BC, r25
    e6f8:	80 93 bb 01 	sts	0x01BB, r24
sectorPerCluster = bpb->sectorPerCluster;
    e6fc:	80 91 e2 01 	lds	r24, 0x01E2
    e700:	90 e0       	ldi	r25, 0x00	; 0
    e702:	90 93 c6 01 	sts	0x01C6, r25
    e706:	80 93 c5 01 	sts	0x01C5, r24
reservedSectorCount = bpb->reservedSectorCount;
    e70a:	c0 90 e3 01 	lds	r12, 0x01E3
    e70e:	d0 90 e4 01 	lds	r13, 0x01E4
    e712:	d0 92 cc 01 	sts	0x01CC, r13
    e716:	c0 92 cb 01 	sts	0x01CB, r12
rootCluster = bpb->rootCluster;
    e71a:	80 91 01 02 	lds	r24, 0x0201
    e71e:	90 91 02 02 	lds	r25, 0x0202
    e722:	a0 91 03 02 	lds	r26, 0x0203
    e726:	b0 91 04 02 	lds	r27, 0x0204
    e72a:	80 93 c1 01 	sts	0x01C1, r24
    e72e:	90 93 c2 01 	sts	0x01C2, r25
    e732:	a0 93 c3 01 	sts	0x01C3, r26
    e736:	b0 93 c4 01 	sts	0x01C4, r27
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);
    e73a:	c0 91 cb 01 	lds	r28, 0x01CB
    e73e:	d0 91 cc 01 	lds	r29, 0x01CC
    e742:	60 91 e5 01 	lds	r22, 0x01E5
    e746:	70 e0       	ldi	r23, 0x00	; 0
    e748:	80 e0       	ldi	r24, 0x00	; 0
    e74a:	90 e0       	ldi	r25, 0x00	; 0
    e74c:	20 91 f9 01 	lds	r18, 0x01F9
    e750:	30 91 fa 01 	lds	r19, 0x01FA
    e754:	40 91 fb 01 	lds	r20, 0x01FB
    e758:	50 91 fc 01 	lds	r21, 0x01FC
    e75c:	74 d3       	rcall	.+1768   	; 0xee46 <__mulsi3>
    e75e:	8b 01       	movw	r16, r22
    e760:	9c 01       	movw	r18, r24
    e762:	ce 01       	movw	r24, r28
    e764:	a0 e0       	ldi	r26, 0x00	; 0
    e766:	b0 e0       	ldi	r27, 0x00	; 0
    e768:	40 91 f1 01 	lds	r20, 0x01F1
    e76c:	50 91 f2 01 	lds	r21, 0x01F2
    e770:	60 91 f3 01 	lds	r22, 0x01F3
    e774:	70 91 f4 01 	lds	r23, 0x01F4
    e778:	84 0f       	add	r24, r20
    e77a:	95 1f       	adc	r25, r21
    e77c:	a6 1f       	adc	r26, r22
    e77e:	b7 1f       	adc	r27, r23
    e780:	80 0f       	add	r24, r16
    e782:	91 1f       	adc	r25, r17
    e784:	a2 1f       	adc	r26, r18
    e786:	b3 1f       	adc	r27, r19
    e788:	80 93 b3 01 	sts	0x01B3, r24
    e78c:	90 93 b4 01 	sts	0x01B4, r25
    e790:	a0 93 b5 01 	sts	0x01B5, r26
    e794:	b0 93 b6 01 	sts	0x01B6, r27

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    e798:	40 91 c5 01 	lds	r20, 0x01C5
    e79c:	50 91 c6 01 	lds	r21, 0x01C6
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
              - bpb->reservedSectorCount
    e7a0:	ee 24       	eor	r14, r14
    e7a2:	ff 24       	eor	r15, r15
    e7a4:	60 91 f5 01 	lds	r22, 0x01F5
    e7a8:	70 91 f6 01 	lds	r23, 0x01F6
    e7ac:	80 91 f7 01 	lds	r24, 0x01F7
    e7b0:	90 91 f8 01 	lds	r25, 0x01F8
    e7b4:	6c 19       	sub	r22, r12
    e7b6:	7d 09       	sbc	r23, r13
    e7b8:	8e 09       	sbc	r24, r14
    e7ba:	9f 09       	sbc	r25, r15
sectorPerCluster = bpb->sectorPerCluster;
reservedSectorCount = bpb->reservedSectorCount;
rootCluster = bpb->rootCluster;
firstDataSector = bpb->hiddenSectors + reservedSectorCount + (bpb->numberofFATs * bpb->FATsize_F32);

dataSectors = bpb->totalSectors_F32
    e7bc:	60 1b       	sub	r22, r16
    e7be:	71 0b       	sbc	r23, r17
    e7c0:	82 0b       	sbc	r24, r18
    e7c2:	93 0b       	sbc	r25, r19
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;
    e7c4:	9a 01       	movw	r18, r20
    e7c6:	40 e0       	ldi	r20, 0x00	; 0
    e7c8:	50 e0       	ldi	r21, 0x00	; 0
    e7ca:	5c d3       	rcall	.+1720   	; 0xee84 <__udivmodsi4>
    e7cc:	20 93 bd 01 	sts	0x01BD, r18
    e7d0:	30 93 be 01 	sts	0x01BE, r19
    e7d4:	40 93 bf 01 	sts	0x01BF, r20
    e7d8:	50 93 c0 01 	sts	0x01C0, r21

return 0;
    e7dc:	80 e0       	ldi	r24, 0x00	; 0
    e7de:	01 c0       	rjmp	.+2      	; 0xe7e2 <getBootSectorData+0x166>
  partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition
  unusedSectors = partition->firstSector; //the unused sectors, hidden to the FAT
  
  SD_readSingleBlock(partition->firstSector);//read the bpb sector
  bpb = (struct BS_Structure *)sd_buffer;
  if(bpb->jumpBoot[0]!=0xE9 && bpb->jumpBoot[0]!=0xEB) return 1; 
    e7e0:	81 e0       	ldi	r24, 0x01	; 1
              - bpb->reservedSectorCount
              - ( bpb->numberofFATs * bpb->FATsize_F32);
totalClusters = dataSectors / sectorPerCluster;

return 0;
}
    e7e2:	cd b7       	in	r28, 0x3d	; 61
    e7e4:	de b7       	in	r29, 0x3e	; 62
    e7e6:	e8 e0       	ldi	r30, 0x08	; 8
    e7e8:	95 c3       	rjmp	.+1834   	; 0xef14 <__epilogue_restores__+0x14>

0000e7ea <getFirstSector>:
//Function: to calculate first sector address of any given cluster
//Arguments: cluster number for which first sector is to be found
//return: first sector address
//***************************************************************************
unsigned long getFirstSector(unsigned long clusterNumber)
{
    e7ea:	ef 92       	push	r14
    e7ec:	ff 92       	push	r15
    e7ee:	0f 93       	push	r16
    e7f0:	1f 93       	push	r17
  return (((clusterNumber - 2) * sectorPerCluster) + firstDataSector);
    e7f2:	20 91 c5 01 	lds	r18, 0x01C5
    e7f6:	30 91 c6 01 	lds	r19, 0x01C6
    e7fa:	e0 90 b3 01 	lds	r14, 0x01B3
    e7fe:	f0 90 b4 01 	lds	r15, 0x01B4
    e802:	00 91 b5 01 	lds	r16, 0x01B5
    e806:	10 91 b6 01 	lds	r17, 0x01B6
    e80a:	62 50       	subi	r22, 0x02	; 2
    e80c:	70 40       	sbci	r23, 0x00	; 0
    e80e:	80 40       	sbci	r24, 0x00	; 0
    e810:	90 40       	sbci	r25, 0x00	; 0
    e812:	40 e0       	ldi	r20, 0x00	; 0
    e814:	50 e0       	ldi	r21, 0x00	; 0
    e816:	17 d3       	rcall	.+1582   	; 0xee46 <__mulsi3>
    e818:	9b 01       	movw	r18, r22
    e81a:	ac 01       	movw	r20, r24
    e81c:	2e 0d       	add	r18, r14
    e81e:	3f 1d       	adc	r19, r15
    e820:	40 1f       	adc	r20, r16
    e822:	51 1f       	adc	r21, r17
}
    e824:	b9 01       	movw	r22, r18
    e826:	ca 01       	movw	r24, r20
    e828:	1f 91       	pop	r17
    e82a:	0f 91       	pop	r16
    e82c:	ff 90       	pop	r15
    e82e:	ef 90       	pop	r14
    e830:	08 95       	ret

0000e832 <getNextCluster>:
//****************************************************************************
unsigned long getNextCluster (unsigned long clusterNumber)
//unsigned long getSetNextCluster (unsigned long clusterNumber,
                                 //unsigned char get_set,
                                 //unsigned long clusterEntry)
{
    e832:	a0 e0       	ldi	r26, 0x00	; 0
    e834:	b0 e0       	ldi	r27, 0x00	; 0
    e836:	ee e1       	ldi	r30, 0x1E	; 30
    e838:	f4 e7       	ldi	r31, 0x74	; 116
    e83a:	4e c3       	rjmp	.+1692   	; 0xeed8 <__prologue_saves__+0x10>
    e83c:	5b 01       	movw	r10, r22
    e83e:	6c 01       	movw	r12, r24
	unsigned long *FATEntryValue;
	unsigned long FATEntrySector;
	unsigned char retry = 0;

	//get sector number of the cluster entry in the FAT
	FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
    e840:	e0 90 cb 01 	lds	r14, 0x01CB
    e844:	f0 90 cc 01 	lds	r15, 0x01CC
    e848:	92 e0       	ldi	r25, 0x02	; 2
    e84a:	aa 0c       	add	r10, r10
    e84c:	bb 1c       	adc	r11, r11
    e84e:	cc 1c       	adc	r12, r12
    e850:	dd 1c       	adc	r13, r13
    e852:	9a 95       	dec	r25
    e854:	d1 f7       	brne	.-12     	; 0xe84a <getNextCluster+0x18>
    e856:	20 91 bb 01 	lds	r18, 0x01BB
    e85a:	30 91 bc 01 	lds	r19, 0x01BC
    e85e:	00 e0       	ldi	r16, 0x00	; 0
    e860:	10 e0       	ldi	r17, 0x00	; 0
    e862:	80 91 c7 01 	lds	r24, 0x01C7
    e866:	90 91 c8 01 	lds	r25, 0x01C8
    e86a:	a0 91 c9 01 	lds	r26, 0x01C9
    e86e:	b0 91 ca 01 	lds	r27, 0x01CA
    e872:	e8 0e       	add	r14, r24
    e874:	f9 1e       	adc	r15, r25
    e876:	0a 1f       	adc	r16, r26
    e878:	1b 1f       	adc	r17, r27
    e87a:	40 e0       	ldi	r20, 0x00	; 0
    e87c:	50 e0       	ldi	r21, 0x00	; 0
    e87e:	c6 01       	movw	r24, r12
    e880:	b5 01       	movw	r22, r10
    e882:	00 d3       	rcall	.+1536   	; 0xee84 <__udivmodsi4>
    e884:	e2 0e       	add	r14, r18
    e886:	f3 1e       	adc	r15, r19
    e888:	04 1f       	adc	r16, r20
    e88a:	15 1f       	adc	r17, r21

	//get the offset address in that sector number
	FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);
    e88c:	20 91 bb 01 	lds	r18, 0x01BB
    e890:	30 91 bc 01 	lds	r19, 0x01BC
    e894:	40 e0       	ldi	r20, 0x00	; 0
    e896:	50 e0       	ldi	r21, 0x00	; 0
    e898:	c6 01       	movw	r24, r12
    e89a:	b5 01       	movw	r22, r10
    e89c:	f3 d2       	rcall	.+1510   	; 0xee84 <__udivmodsi4>
    e89e:	eb 01       	movw	r28, r22
    e8a0:	8a e0       	ldi	r24, 0x0A	; 10
    e8a2:	a8 2e       	mov	r10, r24

	//read the sector into a sd_buffer
	while(retry <10)
	{
		 if(!SD_readSingleBlock(FATEntrySector))
    e8a4:	c8 01       	movw	r24, r16
    e8a6:	b7 01       	movw	r22, r14
    e8a8:	55 d2       	rcall	.+1194   	; 0xed54 <SD_readSingleBlock>
    e8aa:	88 23       	and	r24, r24
    e8ac:	11 f0       	breq	.+4      	; 0xe8b2 <getNextCluster+0x80>
    e8ae:	aa 94       	dec	r10

	//get the offset address in that sector number
	FATEntryOffset = (unsigned int) ((clusterNumber * 4) % bytesPerSector);

	//read the sector into a sd_buffer
	while(retry <10)
    e8b0:	c9 f7       	brne	.-14     	; 0xe8a4 <getNextCluster+0x72>
	}
	//get the cluster address from the sd_buffer
	FATEntryValue = (unsigned long *) &sd_buffer[FATEntryOffset];


	  return ((*FATEntryValue) & 0x0fffffff);
    e8b2:	cb 52       	subi	r28, 0x2B	; 43
    e8b4:	de 4f       	sbci	r29, 0xFE	; 254
    e8b6:	28 81       	ld	r18, Y
    e8b8:	39 81       	ldd	r19, Y+1	; 0x01
    e8ba:	4a 81       	ldd	r20, Y+2	; 0x02
    e8bc:	5b 81       	ldd	r21, Y+3	; 0x03
    e8be:	5f 70       	andi	r21, 0x0F	; 15

}
    e8c0:	b9 01       	movw	r22, r18
    e8c2:	ca 01       	movw	r24, r20
    e8c4:	cd b7       	in	r28, 0x3d	; 61
    e8c6:	de b7       	in	r29, 0x3e	; 62
    e8c8:	ea e0       	ldi	r30, 0x0A	; 10
    e8ca:	22 c3       	rjmp	.+1604   	; 0xef10 <__epilogue_restores__+0x10>

0000e8cc <findFiles>:
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char *fileName)
//struct dir_Structure* findFiles (unsigned char flag, unsigned char *fileName)
{
    e8cc:	a6 e0       	ldi	r26, 0x06	; 6
    e8ce:	b0 e0       	ldi	r27, 0x00	; 0
    e8d0:	eb e6       	ldi	r30, 0x6B	; 107
    e8d2:	f4 e7       	ldi	r31, 0x74	; 116
    e8d4:	f9 c2       	rjmp	.+1522   	; 0xeec8 <__prologue_saves__>
    e8d6:	89 83       	std	Y+1, r24	; 0x01
    e8d8:	9a 83       	std	Y+2, r25	; 0x02
	unsigned long cluster, sector, firstSector;//, firstCluster, nextCluster;
	struct dir_Structure *dir;
	unsigned int i;
	unsigned char j;

	cluster = rootCluster; //root cluster
    e8da:	e0 90 c1 01 	lds	r14, 0x01C1
    e8de:	f0 90 c2 01 	lds	r15, 0x01C2
    e8e2:	00 91 c3 01 	lds	r16, 0x01C3
    e8e6:	10 91 c4 01 	lds	r17, 0x01C4

	while(1)
	{
	   firstSector = getFirstSector (cluster);
    e8ea:	c8 01       	movw	r24, r16
    e8ec:	b7 01       	movw	r22, r14
    e8ee:	7d df       	rcall	.-262    	; 0xe7ea <getFirstSector>
    e8f0:	6b 83       	std	Y+3, r22	; 0x03
    e8f2:	7c 83       	std	Y+4, r23	; 0x04
    e8f4:	8d 83       	std	Y+5, r24	; 0x05
    e8f6:	9e 83       	std	Y+6, r25	; 0x06

	   for(sector = 0; sector < sectorPerCluster; sector++)
    e8f8:	aa 24       	eor	r10, r10
    e8fa:	bb 24       	eor	r11, r11
    e8fc:	65 01       	movw	r12, r10
    e8fe:	71 c0       	rjmp	.+226    	; 0xe9e2 <findFiles+0x116>
    e900:	6b 80       	ldd	r6, Y+3	; 0x03
    e902:	7c 80       	ldd	r7, Y+4	; 0x04
    e904:	8d 80       	ldd	r8, Y+5	; 0x05
    e906:	9e 80       	ldd	r9, Y+6	; 0x06
    e908:	6a 0c       	add	r6, r10
    e90a:	7b 1c       	adc	r7, r11
    e90c:	8c 1c       	adc	r8, r12
    e90e:	9d 1c       	adc	r9, r13
	   {
		 SD_readSingleBlock (firstSector + sector);
    e910:	c4 01       	movw	r24, r8
    e912:	b3 01       	movw	r22, r6
    e914:	1f d2       	rcall	.+1086   	; 0xed54 <SD_readSingleBlock>

		 for(i=0; i<bytesPerSector; i+=32)
    e916:	80 e0       	ldi	r24, 0x00	; 0
    e918:	90 e0       	ldi	r25, 0x00	; 0
    e91a:	56 c0       	rjmp	.+172    	; 0xe9c8 <findFiles+0xfc>
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char *fileName)
    e91c:	fc 01       	movw	r30, r24
    e91e:	eb 52       	subi	r30, 0x2B	; 43
    e920:	fe 4f       	sbci	r31, 0xFE	; 254

		 for(i=0; i<bytesPerSector; i+=32)
		 {
			dir = (struct dir_Structure *) &sd_buffer[i];

			if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
    e922:	20 81       	ld	r18, Z
    e924:	22 23       	and	r18, r18
    e926:	09 f4       	brne	.+2      	; 0xe92a <findFiles+0x5e>
    e928:	7b c0       	rjmp	.+246    	; 0xea20 <findFiles+0x154>
			{
			  return 0;   
			}
			if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
    e92a:	25 3e       	cpi	r18, 0xE5	; 229
    e92c:	09 f4       	brne	.+2      	; 0xe930 <findFiles+0x64>
    e92e:	4b c0       	rjmp	.+150    	; 0xe9c6 <findFiles+0xfa>
    e930:	23 85       	ldd	r18, Z+11	; 0x0b
    e932:	2f 30       	cpi	r18, 0x0F	; 15
    e934:	09 f4       	brne	.+2      	; 0xe938 <findFiles+0x6c>
    e936:	47 c0       	rjmp	.+142    	; 0xe9c6 <findFiles+0xfa>
    e938:	1f 01       	movw	r2, r30
    e93a:	39 81       	ldd	r19, Y+1	; 0x01
    e93c:	2a 81       	ldd	r18, Y+2	; 0x02
    e93e:	63 2f       	mov	r22, r19
    e940:	72 2f       	mov	r23, r18
//Arguments: #1 - flag: GET_LIST, GET_FILE or DELETE #2 - pointer to file name (0 if arg#1 is GET_LIST)
//return: first cluster of the file, if flag = GET_FILE
//        print file/dir list of the root directory, if flag = GET_LIST
//		  Delete the file mentioned in arg#2, if flag = DELETE
//****************************************************************************
struct dir_Structure* findFiles (unsigned char *fileName)
    e942:	20 e0       	ldi	r18, 0x00	; 0
			}
			if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
			{
			  {
				for(j=0; j<11; j++)
				if(dir->name[j] != fileName[j]) break;
    e944:	d1 01       	movw	r26, r2
    e946:	4d 91       	ld	r20, X+
    e948:	1d 01       	movw	r2, r26
    e94a:	db 01       	movw	r26, r22
    e94c:	3d 91       	ld	r19, X+
    e94e:	bd 01       	movw	r22, r26
    e950:	43 17       	cp	r20, r19
    e952:	c9 f5       	brne	.+114    	; 0xe9c6 <findFiles+0xfa>
			  return 0;   
			}
			if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
			{
			  {
				for(j=0; j<11; j++)
    e954:	2f 5f       	subi	r18, 0xFF	; 255
    e956:	2b 30       	cpi	r18, 0x0B	; 11
    e958:	a9 f7       	brne	.-22     	; 0xe944 <findFiles+0x78>
				if(dir->name[j] != fileName[j]) break;
				if(j == 11)
				{
					appendFileSector = firstSector + sector;
    e95a:	60 92 d1 01 	sts	0x01D1, r6
    e95e:	70 92 d2 01 	sts	0x01D2, r7
    e962:	80 92 d3 01 	sts	0x01D3, r8
    e966:	90 92 d4 01 	sts	0x01D4, r9
					appendFileLocation = i;
    e96a:	a0 e0       	ldi	r26, 0x00	; 0
    e96c:	b0 e0       	ldi	r27, 0x00	; 0
    e96e:	80 93 af 01 	sts	0x01AF, r24
    e972:	90 93 b0 01 	sts	0x01B0, r25
    e976:	a0 93 b1 01 	sts	0x01B1, r26
    e97a:	b0 93 b2 01 	sts	0x01B2, r27
					appendStartCluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    e97e:	84 89       	ldd	r24, Z+20	; 0x14
    e980:	95 89       	ldd	r25, Z+21	; 0x15
    e982:	a0 e0       	ldi	r26, 0x00	; 0
    e984:	b0 e0       	ldi	r27, 0x00	; 0
    e986:	dc 01       	movw	r26, r24
    e988:	99 27       	eor	r25, r25
    e98a:	88 27       	eor	r24, r24
    e98c:	22 8d       	ldd	r18, Z+26	; 0x1a
    e98e:	33 8d       	ldd	r19, Z+27	; 0x1b
    e990:	40 e0       	ldi	r20, 0x00	; 0
    e992:	50 e0       	ldi	r21, 0x00	; 0
    e994:	82 2b       	or	r24, r18
    e996:	93 2b       	or	r25, r19
    e998:	a4 2b       	or	r26, r20
    e99a:	b5 2b       	or	r27, r21
    e99c:	80 93 cd 01 	sts	0x01CD, r24
    e9a0:	90 93 ce 01 	sts	0x01CE, r25
    e9a4:	a0 93 cf 01 	sts	0x01CF, r26
    e9a8:	b0 93 d0 01 	sts	0x01D0, r27
					fileSize = dir->fileSize;
    e9ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    e9ae:	95 8d       	ldd	r25, Z+29	; 0x1d
    e9b0:	a6 8d       	ldd	r26, Z+30	; 0x1e
    e9b2:	b7 8d       	ldd	r27, Z+31	; 0x1f
    e9b4:	80 93 b7 01 	sts	0x01B7, r24
    e9b8:	90 93 b8 01 	sts	0x01B8, r25
    e9bc:	a0 93 b9 01 	sts	0x01B9, r26
    e9c0:	b0 93 ba 01 	sts	0x01BA, r27
					return (dir);
    e9c4:	2f c0       	rjmp	.+94     	; 0xea24 <findFiles+0x158>

	   for(sector = 0; sector < sectorPerCluster; sector++)
	   {
		 SD_readSingleBlock (firstSector + sector);

		 for(i=0; i<bytesPerSector; i+=32)
    e9c6:	80 96       	adiw	r24, 0x20	; 32
    e9c8:	20 91 bb 01 	lds	r18, 0x01BB
    e9cc:	30 91 bc 01 	lds	r19, 0x01BC
    e9d0:	82 17       	cp	r24, r18
    e9d2:	93 07       	cpc	r25, r19
    e9d4:	08 f4       	brcc	.+2      	; 0xe9d8 <findFiles+0x10c>
    e9d6:	a2 cf       	rjmp	.-188    	; 0xe91c <findFiles+0x50>

	while(1)
	{
	   firstSector = getFirstSector (cluster);

	   for(sector = 0; sector < sectorPerCluster; sector++)
    e9d8:	08 94       	sec
    e9da:	a1 1c       	adc	r10, r1
    e9dc:	b1 1c       	adc	r11, r1
    e9de:	c1 1c       	adc	r12, r1
    e9e0:	d1 1c       	adc	r13, r1
    e9e2:	80 91 c5 01 	lds	r24, 0x01C5
    e9e6:	90 91 c6 01 	lds	r25, 0x01C6
    e9ea:	a0 e0       	ldi	r26, 0x00	; 0
    e9ec:	b0 e0       	ldi	r27, 0x00	; 0
    e9ee:	a8 16       	cp	r10, r24
    e9f0:	b9 06       	cpc	r11, r25
    e9f2:	ca 06       	cpc	r12, r26
    e9f4:	db 06       	cpc	r13, r27
    e9f6:	08 f4       	brcc	.+2      	; 0xe9fa <findFiles+0x12e>
    e9f8:	83 cf       	rjmp	.-250    	; 0xe900 <findFiles+0x34>
			  }
	  	     }
		 }
	   }
		
		cluster = (getNextCluster (cluster));
    e9fa:	c8 01       	movw	r24, r16
    e9fc:	b7 01       	movw	r22, r14
    e9fe:	19 df       	rcall	.-462    	; 0xe832 <getNextCluster>
    ea00:	7b 01       	movw	r14, r22
    ea02:	8c 01       	movw	r16, r24

		if(cluster > 0x0ffffff6)
    ea04:	67 3f       	cpi	r22, 0xF7	; 247
    ea06:	bf ef       	ldi	r27, 0xFF	; 255
    ea08:	7b 07       	cpc	r23, r27
    ea0a:	bf ef       	ldi	r27, 0xFF	; 255
    ea0c:	8b 07       	cpc	r24, r27
    ea0e:	bf e0       	ldi	r27, 0x0F	; 15
    ea10:	9b 07       	cpc	r25, r27
    ea12:	30 f4       	brcc	.+12     	; 0xea20 <findFiles+0x154>
   			return 0;
		if(cluster == 0) 
    ea14:	61 15       	cp	r22, r1
    ea16:	71 05       	cpc	r23, r1
    ea18:	81 05       	cpc	r24, r1
    ea1a:	91 05       	cpc	r25, r1
    ea1c:	09 f0       	breq	.+2      	; 0xea20 <findFiles+0x154>
    ea1e:	65 cf       	rjmp	.-310    	; 0xe8ea <findFiles+0x1e>
	   }
		
		cluster = (getNextCluster (cluster));

		if(cluster > 0x0ffffff6)
   			return 0;
    ea20:	e0 e0       	ldi	r30, 0x00	; 0
    ea22:	f0 e0       	ldi	r31, 0x00	; 0
			return 0;
		}
	
	 }
	return 0;
}
    ea24:	cf 01       	movw	r24, r30
    ea26:	26 96       	adiw	r28, 0x06	; 6
    ea28:	e2 e1       	ldi	r30, 0x12	; 18
    ea2a:	6a c2       	rjmp	.+1236   	; 0xef00 <__epilogue_restores__>

0000ea2c <readFile>:
//	      1, if file is already existing and flag = VERIFY
//		  2, if file name is incompatible
//***************************************************************************

void readFile ( unsigned char *fileName)
{
    ea2c:	4f 92       	push	r4
    ea2e:	5f 92       	push	r5
    ea30:	6f 92       	push	r6
    ea32:	7f 92       	push	r7
    ea34:	9f 92       	push	r9
    ea36:	af 92       	push	r10
    ea38:	bf 92       	push	r11
    ea3a:	cf 92       	push	r12
    ea3c:	df 92       	push	r13
    ea3e:	ef 92       	push	r14
    ea40:	ff 92       	push	r15
    ea42:	0f 93       	push	r16
    ea44:	1f 93       	push	r17
/*
error = convertFileName (fileName); //convert fileName into FAT format
if(error) return 2;
*/

dir = findFiles (fileName); //get the file location
    ea46:	42 df       	rcall	.-380    	; 0xe8cc <findFiles>
    ea48:	fc 01       	movw	r30, r24
if(dir == 0) 
    ea4a:	00 97       	sbiw	r24, 0x00	; 0
    ea4c:	29 f4       	brne	.+10     	; 0xea58 <readFile+0x2c>
{
	lcd_clear();
    ea4e:	dc dd       	rcall	.-1096   	; 0xe608 <lcd_clear>
	lcd_string("Firmware error");
    ea50:	8a e4       	ldi	r24, 0x4A	; 74
    ea52:	91 e0       	ldi	r25, 0x01	; 1
    ea54:	00 de       	rcall	.-1024   	; 0xe656 <lcd_string>
    ea56:	ff cf       	rjmp	.-2      	; 0xea56 <readFile+0x2a>
}	
  

//if(flag == VERIFY) return (1);	//specified file name is already existing

cluster = (((unsigned long) dir->firstClusterHI) << 16) | dir->firstClusterLO;
    ea58:	e4 88       	ldd	r14, Z+20	; 0x14
    ea5a:	f5 88       	ldd	r15, Z+21	; 0x15
    ea5c:	00 e0       	ldi	r16, 0x00	; 0
    ea5e:	10 e0       	ldi	r17, 0x00	; 0
    ea60:	87 01       	movw	r16, r14
    ea62:	ff 24       	eor	r15, r15
    ea64:	ee 24       	eor	r14, r14
    ea66:	22 8d       	ldd	r18, Z+26	; 0x1a
    ea68:	33 8d       	ldd	r19, Z+27	; 0x1b
    ea6a:	40 e0       	ldi	r20, 0x00	; 0
    ea6c:	50 e0       	ldi	r21, 0x00	; 0
    ea6e:	e2 2a       	or	r14, r18
    ea70:	f3 2a       	or	r15, r19
    ea72:	04 2b       	or	r16, r20
    ea74:	15 2b       	or	r17, r21

fileSize = dir->fileSize;
    ea76:	44 8c       	ldd	r4, Z+28	; 0x1c
    ea78:	55 8c       	ldd	r5, Z+29	; 0x1d
    ea7a:	66 8c       	ldd	r6, Z+30	; 0x1e
    ea7c:	77 8c       	ldd	r7, Z+31	; 0x1f
//TX_NEWLINE;
//TX_NEWLINE;

while(1)
{
  firstSector = getFirstSector (cluster);
    ea7e:	c8 01       	movw	r24, r16
    ea80:	b7 01       	movw	r22, r14
    ea82:	b3 de       	rcall	.-666    	; 0xe7ea <getFirstSector>
    ea84:	5b 01       	movw	r10, r22
    ea86:	6c 01       	movw	r12, r24

  for(j=0; j<sectorPerCluster; j++)
    ea88:	99 24       	eor	r9, r9
    ea8a:	0d c0       	rjmp	.+26     	; 0xeaa6 <readFile+0x7a>
  {
    SD_readSingleBlock(firstSector + j);
    ea8c:	c6 01       	movw	r24, r12
    ea8e:	b5 01       	movw	r22, r10
    ea90:	69 0d       	add	r22, r9
    ea92:	71 1d       	adc	r23, r1
    ea94:	81 1d       	adc	r24, r1
    ea96:	91 1d       	adc	r25, r1
    ea98:	5d d1       	rcall	.+698    	; 0xed54 <SD_readSingleBlock>
	

	if(!fileParser_parseNextBlock(fileSize))
    ea9a:	c3 01       	movw	r24, r6
    ea9c:	b2 01       	movw	r22, r4
    ea9e:	84 db       	rcall	.-2296   	; 0xe1a8 <fileParser_parseNextBlock>
    eaa0:	88 23       	and	r24, r24
    eaa2:	a1 f0       	breq	.+40     	; 0xeacc <readFile+0xa0>

while(1)
{
  firstSector = getFirstSector (cluster);

  for(j=0; j<sectorPerCluster; j++)
    eaa4:	93 94       	inc	r9
    eaa6:	80 91 c5 01 	lds	r24, 0x01C5
    eaaa:	90 91 c6 01 	lds	r25, 0x01C6
    eaae:	29 2d       	mov	r18, r9
    eab0:	30 e0       	ldi	r19, 0x00	; 0
    eab2:	28 17       	cp	r18, r24
    eab4:	39 07       	cpc	r19, r25
    eab6:	50 f3       	brcs	.-44     	; 0xea8c <readFile+0x60>
		return;
	};
	
  }

  cluster = getNextCluster (cluster);
    eab8:	c8 01       	movw	r24, r16
    eaba:	b7 01       	movw	r22, r14
    eabc:	ba de       	rcall	.-652    	; 0xe832 <getNextCluster>
    eabe:	7b 01       	movw	r14, r22
    eac0:	8c 01       	movw	r16, r24
  if(cluster == 0) 
    eac2:	61 15       	cp	r22, r1
    eac4:	71 05       	cpc	r23, r1
    eac6:	81 05       	cpc	r24, r1
    eac8:	91 05       	cpc	r25, r1
    eaca:	c9 f6       	brne	.-78     	; 0xea7e <readFile+0x52>
  {
	return;
  }
}
return;
}
    eacc:	1f 91       	pop	r17
    eace:	0f 91       	pop	r16
    ead0:	ff 90       	pop	r15
    ead2:	ef 90       	pop	r14
    ead4:	df 90       	pop	r13
    ead6:	cf 90       	pop	r12
    ead8:	bf 90       	pop	r11
    eada:	af 90       	pop	r10
    eadc:	9f 90       	pop	r9
    eade:	7f 90       	pop	r7
    eae0:	6f 90       	pop	r6
    eae2:	5f 90       	pop	r5
    eae4:	4f 90       	pop	r4
    eae6:	08 95       	ret

0000eae8 <port_init>:
#include "userInterface.h"


void port_init(void)
{
PORTA = 0x00;
    eae8:	12 b8       	out	0x02, r1	; 2
DDRA  = 0x00;
    eaea:	11 b8       	out	0x01, r1	; 1
PORTB = 0xEF;
    eaec:	8f ee       	ldi	r24, 0xEF	; 239
    eaee:	85 b9       	out	0x05, r24	; 5
DDRB  = 0xBF; //MISO line i/p, rest o/p
    eaf0:	8f eb       	ldi	r24, 0xBF	; 191
    eaf2:	84 b9       	out	0x04, r24	; 4
PORTC = 0x00;
    eaf4:	18 b8       	out	0x08, r1	; 8
DDRC  = 0x00;
    eaf6:	17 b8       	out	0x07, r1	; 7
PORTD = 0x00;
    eaf8:	1b b8       	out	0x0b, r1	; 11
//DDRD  = 0xFE;

//init cortex reset output pin
	//as input
	CORTEX_RESET_DDR &= ~(1<<CORTEX_RESET_PIN);
    eafa:	57 98       	cbi	0x0a, 7	; 10
	//no pull up
	CORTEX_RESET_PORT &= ~(1<<CORTEX_RESET_PIN);
    eafc:	5f 98       	cbi	0x0b, 7	; 11


}
    eafe:	08 95       	ret

0000eb00 <init_devices>:
void (*start)( void ) = 0x0000;
//---------------------------------------------------------------------
//call this routine to initialize all peripherals
void init_devices(void)
{
 cli();  //all interrupts disabled
    eb00:	f8 94       	cli
 port_init();
    eb02:	f2 df       	rcall	.-28     	; 0xeae8 <port_init>
 spi_init();
    eb04:	53 d1       	rcall	.+678    	; 0xedac <spi_init>

// twi_init();
 uart_init();
    eb06:	63 d1       	rcall	.+710    	; 0xedce <uart_init>

 MCUCR = 0x00;
    eb08:	15 be       	out	0x35, r1	; 53
#ifdef MEGA32 
 GICR  = 0x00;
 TIMSK = 0x00; //timer interrupt sources
#else
// MCUCR  = 0x00;
 TIMSK0 = 0x00; //timer interrupt sources
    eb0a:	10 92 6e 00 	sts	0x006E, r1
#endif
 //all peripherals are now initialized
 
  lcd_init();
 
}
    eb0e:	22 cd       	rjmp	.-1468   	; 0xe554 <lcd_init>

0000eb10 <main>:
    eb10:	8f e7       	ldi	r24, 0x7F	; 127
    eb12:	9a e1       	ldi	r25, 0x1A	; 26
    eb14:	a6 e0       	ldi	r26, 0x06	; 6
    eb16:	81 50       	subi	r24, 0x01	; 1
    eb18:	90 40       	sbci	r25, 0x00	; 0
    eb1a:	a0 40       	sbci	r26, 0x00	; 0
    eb1c:	e1 f7       	brne	.-8      	; 0xeb16 <main+0x6>
    eb1e:	00 c0       	rjmp	.+0      	; 0xeb20 <main+0x10>
    eb20:	00 00       	nop
	_delay_ms(100);  //delay for VCC stabilization
	

	
	 //init user ui
	ui_init();
    eb22:	8a d1       	rcall	.+788    	; 0xee38 <ui_init>
	
	if(ui_isButtonPressed())
    eb24:	8c d1       	rcall	.+792    	; 0xee3e <ui_isButtonPressed>
    eb26:	88 23       	and	r24, r24
    eb28:	09 f4       	brne	.+2      	; 0xeb2c <main+0x1c>
    eb2a:	4a c0       	rjmp	.+148    	; 0xebc0 <main+0xb0>
	{
		init_devices();
    eb2c:	e9 df       	rcall	.-46     	; 0xeb00 <init_devices>
		lcd_string("bootloader");
    eb2e:	89 e5       	ldi	r24, 0x59	; 89
    eb30:	91 e0       	ldi	r25, 0x01	; 1
    eb32:	91 dd       	rcall	.-1246   	; 0xe656 <lcd_string>
    eb34:	8f e7       	ldi	r24, 0x7F	; 127
    eb36:	94 e8       	ldi	r25, 0x84	; 132
    eb38:	ae e1       	ldi	r26, 0x1E	; 30
    eb3a:	81 50       	subi	r24, 0x01	; 1
    eb3c:	90 40       	sbci	r25, 0x00	; 0
    eb3e:	a0 40       	sbci	r26, 0x00	; 0
    eb40:	e1 f7       	brne	.-8      	; 0xeb3a <main+0x2a>
    eb42:	00 c0       	rjmp	.+0      	; 0xeb44 <main+0x34>
    eb44:	00 00       	nop
		_delay_ms(500);
		cardType = 0;
    eb46:	10 92 ae 01 	sts	0x01AE, r1
    eb4a:	ca e0       	ldi	r28, 0x0A	; 10
    eb4c:	d0 e0       	ldi	r29, 0x00	; 0

		for (i=0; i<10; i++)
		{
		  error = SD_init();
    eb4e:	41 d0       	rcall	.+130    	; 0xebd2 <SD_init>
		  if(!error) break;
    eb50:	88 23       	and	r24, r24
    eb52:	89 f0       	breq	.+34     	; 0xeb76 <main+0x66>
    eb54:	21 97       	sbiw	r28, 0x01	; 1
		init_devices();
		lcd_string("bootloader");
		_delay_ms(500);
		cardType = 0;

		for (i=0; i<10; i++)
    eb56:	d9 f7       	brne	.-10     	; 0xeb4e <main+0x3e>
		  if(!error) break;
		}

		if(error)
		{
			lcd_clear();
    eb58:	57 dd       	rcall	.-1362   	; 0xe608 <lcd_clear>
			lcd_home();
    eb5a:	5f dd       	rcall	.-1346   	; 0xe61a <lcd_home>
			lcd_string("SD error");
    eb5c:	84 e6       	ldi	r24, 0x64	; 100
    eb5e:	91 e0       	ldi	r25, 0x01	; 1
    eb60:	7a dd       	rcall	.-1292   	; 0xe656 <lcd_string>
    eb62:	8f e7       	ldi	r24, 0x7F	; 127
    eb64:	9a e1       	ldi	r25, 0x1A	; 26
    eb66:	a6 e0       	ldi	r26, 0x06	; 6
    eb68:	81 50       	subi	r24, 0x01	; 1
    eb6a:	90 40       	sbci	r25, 0x00	; 0
    eb6c:	a0 40       	sbci	r26, 0x00	; 0
    eb6e:	e1 f7       	brne	.-8      	; 0xeb68 <main+0x58>
    eb70:	00 c0       	rjmp	.+0      	; 0xeb72 <main+0x62>
    eb72:	00 00       	nop
    eb74:	f6 cf       	rjmp	.-20     	; 0xeb62 <main+0x52>
			}
		}
		else
		{

			SPI_HIGH_SPEED;	//SCK - 4 MHz
    eb76:	80 e5       	ldi	r24, 0x50	; 80
    eb78:	8c bd       	out	0x2c, r24	; 44
    eb7a:	8d b5       	in	r24, 0x2d	; 45
    eb7c:	81 60       	ori	r24, 0x01	; 1
    eb7e:	8d bd       	out	0x2d, r24	; 45
    eb80:	a7 e8       	ldi	r26, 0x87	; 135
    eb82:	b3 e1       	ldi	r27, 0x13	; 19
    eb84:	11 97       	sbiw	r26, 0x01	; 1
    eb86:	f1 f7       	brne	.-4      	; 0xeb84 <main+0x74>
    eb88:	00 c0       	rjmp	.+0      	; 0xeb8a <main+0x7a>
    eb8a:	00 00       	nop
			_delay_ms(1);   //some delay

			error = getBootSectorData (); //read boot sector and keep necessary data in global variables
    eb8c:	77 dd       	rcall	.-1298   	; 0xe67c <getBootSectorData>
			if(error) 	
    eb8e:	88 23       	and	r24, r24
    eb90:	71 f0       	breq	.+28     	; 0xebae <main+0x9e>
			{
				lcd_clear();
    eb92:	3a dd       	rcall	.-1420   	; 0xe608 <lcd_clear>
				lcd_string("FS error");
    eb94:	8d e6       	ldi	r24, 0x6D	; 109
    eb96:	91 e0       	ldi	r25, 0x01	; 1
    eb98:	5e dd       	rcall	.-1348   	; 0xe656 <lcd_string>
    eb9a:	8f e7       	ldi	r24, 0x7F	; 127
    eb9c:	94 e8       	ldi	r25, 0x84	; 132
    eb9e:	ae e1       	ldi	r26, 0x1E	; 30
    eba0:	81 50       	subi	r24, 0x01	; 1
    eba2:	90 40       	sbci	r25, 0x00	; 0
    eba4:	a0 40       	sbci	r26, 0x00	; 0
    eba6:	e1 f7       	brne	.-8      	; 0xeba0 <main+0x90>
    eba8:	00 c0       	rjmp	.+0      	; 0xebaa <main+0x9a>
    ebaa:	00 00       	nop
    ebac:	f6 cf       	rjmp	.-20     	; 0xeb9a <main+0x8a>
				}				  
			}
			else
			{
				//name without dot -> 11 byte in fat entry
				readFile((unsigned char*)"FIRMWAREBIN");	
    ebae:	86 e7       	ldi	r24, 0x76	; 118
    ebb0:	91 e0       	ldi	r25, 0x01	; 1
    ebb2:	3c df       	rcall	.-392    	; 0xea2c <readFile>
				
				
				//software reset
				//wdt_enable(WDTO_15MS) ;
				//while(1);
				cli();
    ebb4:	f8 94       	cli
				start();
    ebb6:	e0 91 99 01 	lds	r30, 0x0199
    ebba:	f0 91 9a 01 	lds	r31, 0x019A
    ebbe:	09 95       	icall
	//Start normal program
	/* vor Rücksprung eventuell benutzte Hardware deaktivieren
       und Interrupts global deaktivieren, da kein "echter" Reset erfolgt */
 
    /* Interrupt Vektoren wieder gerade biegen */
    cli();
    ebc0:	f8 94       	cli
 
    /* Rücksprung zur Adresse 0x0000 */
//	SIGNAL_LED_PORT |= ((1<<SIGNAL_LED));

	//EIND = 0;
    start(); 
    ebc2:	e0 91 99 01 	lds	r30, 0x0199
    ebc6:	f0 91 9a 01 	lds	r31, 0x019A
    ebca:	09 95       	icall

//	return 0;
}
    ebcc:	80 e0       	ldi	r24, 0x00	; 0
    ebce:	90 e0       	ldi	r25, 0x00	; 0
    ebd0:	08 95       	ret

0000ebd2 <SD_init>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_init(void)
{
    ebd2:	1f 93       	push	r17
    ebd4:	cf 93       	push	r28
    ebd6:	df 93       	push	r29
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;

	 for(i=0;i<10;i++)
    ebd8:	10 e0       	ldi	r17, 0x00	; 0
		  SPI_transmit(0xff);   //80 clock pulses spent before sending the first command
    ebda:	8f ef       	ldi	r24, 0xFF	; 255
    ebdc:	eb d0       	rcall	.+470    	; 0xedb4 <SPI_transmit>
unsigned char SD_init(void)
{
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;

	 for(i=0;i<10;i++)
    ebde:	1f 5f       	subi	r17, 0xFF	; 255
    ebe0:	1a 30       	cpi	r17, 0x0A	; 10
    ebe2:	d9 f7       	brne	.-10     	; 0xebda <SD_init+0x8>
		  SPI_transmit(0xff);   //80 clock pulses spent before sending the first command

	SD_CS_ASSERT;
    ebe4:	2c 98       	cbi	0x05, 4	; 5
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_init(void)
{
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;
    ebe6:	c0 e0       	ldi	r28, 0x00	; 0
    ebe8:	d0 e0       	ldi	r29, 0x00	; 0

	SD_CS_ASSERT;
	do
	{
  
	   response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
    ebea:	80 e0       	ldi	r24, 0x00	; 0
    ebec:	40 e0       	ldi	r20, 0x00	; 0
    ebee:	50 e0       	ldi	r21, 0x00	; 0
    ebf0:	ba 01       	movw	r22, r20
    ebf2:	5a d0       	rcall	.+180    	; 0xeca8 <SD_sendCommand>
	   retry++;
    ebf4:	21 96       	adiw	r28, 0x01	; 1
	   if(retry>0x20) 
    ebf6:	c1 32       	cpi	r28, 0x21	; 33
    ebf8:	d1 05       	cpc	r29, r1
    ebfa:	09 f4       	brne	.+2      	; 0xebfe <SD_init+0x2c>
    ebfc:	4c c0       	rjmp	.+152    	; 0xec96 <SD_init+0xc4>
   		  return 1;   //time out, card not detected
   
	} while(response != 0x01);
    ebfe:	81 30       	cpi	r24, 0x01	; 1
    ec00:	a1 f7       	brne	.-24     	; 0xebea <SD_init+0x18>

	SD_CS_DEASSERT;
    ec02:	2c 9a       	sbi	0x05, 4	; 5
	SPI_transmit (0xff);
    ec04:	8f ef       	ldi	r24, 0xFF	; 255
    ec06:	d6 d0       	rcall	.+428    	; 0xedb4 <SPI_transmit>
	SPI_transmit (0xff);
    ec08:	8f ef       	ldi	r24, 0xFF	; 255
    ec0a:	d4 d0       	rcall	.+424    	; 0xedb4 <SPI_transmit>

	retry = 0;
    ec0c:	c0 e0       	ldi	r28, 0x00	; 0
    ec0e:	d0 e0       	ldi	r29, 0x00	; 0

	SD_version = 2; //default set to SD compliance with ver2.x; 
					//this may change after checking the next command
	do
	{
	response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
    ec10:	88 e0       	ldi	r24, 0x08	; 8
    ec12:	4a ea       	ldi	r20, 0xAA	; 170
    ec14:	51 e0       	ldi	r21, 0x01	; 1
    ec16:	60 e0       	ldi	r22, 0x00	; 0
    ec18:	70 e0       	ldi	r23, 0x00	; 0
    ec1a:	46 d0       	rcall	.+140    	; 0xeca8 <SD_sendCommand>
	retry++;
    ec1c:	21 96       	adiw	r28, 0x01	; 1
	if(retry>0xfe) 
    ec1e:	cf 3f       	cpi	r28, 0xFF	; 255
    ec20:	d1 05       	cpc	r29, r1
    ec22:	29 f4       	brne	.+10     	; 0xec2e <SD_init+0x5c>
	   {
		  //TX_NEWLINE;
		  SD_version = 1;
		  cardType = 1;
    ec24:	81 e0       	ldi	r24, 0x01	; 1
    ec26:	80 93 ae 01 	sts	0x01AE, r24
	response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
	retry++;
	if(retry>0xfe) 
	   {
		  //TX_NEWLINE;
		  SD_version = 1;
    ec2a:	11 e0       	ldi	r17, 0x01	; 1
		  cardType = 1;
		  break;
    ec2c:	03 c0       	rjmp	.+6      	; 0xec34 <SD_init+0x62>
	   } //time out

	}while(response != 0x01);
    ec2e:	81 30       	cpi	r24, 0x01	; 1
    ec30:	79 f7       	brne	.-34     	; 0xec10 <SD_init+0x3e>
	SPI_transmit (0xff);
	SPI_transmit (0xff);

	retry = 0;

	SD_version = 2; //default set to SD compliance with ver2.x; 
    ec32:	12 e0       	ldi	r17, 0x02	; 2
		  break;
	   } //time out

	}while(response != 0x01);

	retry = 0;
    ec34:	c0 e0       	ldi	r28, 0x00	; 0
    ec36:	d0 e0       	ldi	r29, 0x00	; 0

	do
	{
	response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
    ec38:	87 e3       	ldi	r24, 0x37	; 55
    ec3a:	40 e0       	ldi	r20, 0x00	; 0
    ec3c:	50 e0       	ldi	r21, 0x00	; 0
    ec3e:	ba 01       	movw	r22, r20
    ec40:	33 d0       	rcall	.+102    	; 0xeca8 <SD_sendCommand>
	response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
    ec42:	89 e2       	ldi	r24, 0x29	; 41
    ec44:	40 e0       	ldi	r20, 0x00	; 0
    ec46:	50 e0       	ldi	r21, 0x00	; 0
    ec48:	60 e0       	ldi	r22, 0x00	; 0
    ec4a:	70 e4       	ldi	r23, 0x40	; 64
    ec4c:	2d d0       	rcall	.+90     	; 0xeca8 <SD_sendCommand>

	retry++;
    ec4e:	21 96       	adiw	r28, 0x01	; 1
	if(retry>0xfe) 
    ec50:	cf 3f       	cpi	r28, 0xFF	; 255
    ec52:	d1 05       	cpc	r29, r1
    ec54:	11 f1       	breq	.+68     	; 0xec9a <SD_init+0xc8>
	   {
		  
		  return 2;  //time out, card initialization failed
	   } 

	}while(response != 0x00);
    ec56:	88 23       	and	r24, r24
    ec58:	79 f7       	brne	.-34     	; 0xec38 <SD_init+0x66>


	retry = 0;
	SDHC_flag = 0;
    ec5a:	10 92 a9 01 	sts	0x01A9, r1

	if (SD_version == 2)
    ec5e:	12 30       	cpi	r17, 0x02	; 2
    ec60:	f1 f4       	brne	.+60     	; 0xec9e <SD_init+0xcc>
    ec62:	c0 e0       	ldi	r28, 0x00	; 0
    ec64:	d0 e0       	ldi	r29, 0x00	; 0
	{ 
	   do
	   {
		 response = SD_sendCommand(READ_OCR,0);
    ec66:	8a e3       	ldi	r24, 0x3A	; 58
    ec68:	40 e0       	ldi	r20, 0x00	; 0
    ec6a:	50 e0       	ldi	r21, 0x00	; 0
    ec6c:	ba 01       	movw	r22, r20
    ec6e:	1c d0       	rcall	.+56     	; 0xeca8 <SD_sendCommand>
		 retry++;
    ec70:	21 96       	adiw	r28, 0x01	; 1
		 if(retry>0xfe) 
    ec72:	cf 3f       	cpi	r28, 0xFF	; 255
    ec74:	d1 05       	cpc	r29, r1
    ec76:	19 f4       	brne	.+6      	; 0xec7e <SD_init+0xac>
		 {
		   
		   cardType = 0;
    ec78:	10 92 ae 01 	sts	0x01AE, r1
		   break;
    ec7c:	02 c0       	rjmp	.+4      	; 0xec82 <SD_init+0xb0>
		 } //time out

	   }while(response != 0x00);
    ec7e:	88 23       	and	r24, r24
    ec80:	91 f7       	brne	.-28     	; 0xec66 <SD_init+0x94>

	   if(SDHC_flag == 1) cardType = 2;
    ec82:	80 91 a9 01 	lds	r24, 0x01A9
    ec86:	81 30       	cpi	r24, 0x01	; 1
    ec88:	11 f4       	brne	.+4      	; 0xec8e <SD_init+0xbc>
    ec8a:	82 e0       	ldi	r24, 0x02	; 2
    ec8c:	01 c0       	rjmp	.+2      	; 0xec90 <SD_init+0xbe>
	   else cardType = 3;
    ec8e:	83 e0       	ldi	r24, 0x03	; 3
    ec90:	80 93 ae 01 	sts	0x01AE, r24
    ec94:	04 c0       	rjmp	.+8      	; 0xec9e <SD_init+0xcc>
	{
  
	   response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
	   retry++;
	   if(retry>0x20) 
   		  return 1;   //time out, card not detected
    ec96:	81 e0       	ldi	r24, 0x01	; 1
    ec98:	03 c0       	rjmp	.+6      	; 0xeca0 <SD_init+0xce>

	retry++;
	if(retry>0xfe) 
	   {
		  
		  return 2;  //time out, card initialization failed
    ec9a:	82 e0       	ldi	r24, 0x02	; 2
    ec9c:	01 c0       	rjmp	.+2      	; 0xeca0 <SD_init+0xce>

	//SD_sendCommand(CRC_ON_OFF, OFF); //disable CRC; deafault - CRC disabled in SPI mode
	//SD_sendCommand(SET_BLOCK_LEN, 512); //set block size to 512; default size is 512


	return 0; //successful return
    ec9e:	80 e0       	ldi	r24, 0x00	; 0
}
    eca0:	df 91       	pop	r29
    eca2:	cf 91       	pop	r28
    eca4:	1f 91       	pop	r17
    eca6:	08 95       	ret

0000eca8 <SD_sendCommand>:
//Arguments	: unsigned char (8-bit command value)
// 			  & unsigned long (32-bit command argument)
//return	: unsigned char; response byte
//******************************************************************
unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)
{
    eca8:	a1 e0       	ldi	r26, 0x01	; 1
    ecaa:	b0 e0       	ldi	r27, 0x00	; 0
    ecac:	e9 e5       	ldi	r30, 0x59	; 89
    ecae:	f6 e7       	ldi	r31, 0x76	; 118
    ecb0:	17 c1       	rjmp	.+558    	; 0xeee0 <__prologue_saves__+0x18>
    ecb2:	98 2f       	mov	r25, r24
    ecb4:	7a 01       	movw	r14, r20
    ecb6:	8b 01       	movw	r16, r22
//SD card accepts byte address while SDHC accepts block address in multiples of 512
//so, if it's SD card we need to convert block address into corresponding byte address by 
//multipying it with 512. which is equivalent to shifting it left 9 times
//following 'if' loop does that

if(SDHC_flag == 0)		
    ecb8:	80 91 a9 01 	lds	r24, 0x01A9
    ecbc:	88 23       	and	r24, r24
    ecbe:	99 f4       	brne	.+38     	; 0xece6 <SD_sendCommand+0x3e>
if(cmd == READ_SINGLE_BLOCK     ||
    ecc0:	89 2f       	mov	r24, r25
    ecc2:	81 51       	subi	r24, 0x11	; 17
    ecc4:	82 30       	cpi	r24, 0x02	; 2
    ecc6:	40 f0       	brcs	.+16     	; 0xecd8 <SD_sendCommand+0x30>
   cmd == READ_MULTIPLE_BLOCKS  ||
    ecc8:	98 31       	cpi	r25, 0x18	; 24
    ecca:	31 f0       	breq	.+12     	; 0xecd8 <SD_sendCommand+0x30>
   cmd == WRITE_SINGLE_BLOCK    ||
    eccc:	99 31       	cpi	r25, 0x19	; 25
    ecce:	21 f0       	breq	.+8      	; 0xecd8 <SD_sendCommand+0x30>
   cmd == WRITE_MULTIPLE_BLOCKS ||
    ecd0:	90 32       	cpi	r25, 0x20	; 32
    ecd2:	11 f0       	breq	.+4      	; 0xecd8 <SD_sendCommand+0x30>
   cmd == ERASE_BLOCK_START_ADDR|| 
    ecd4:	91 32       	cpi	r25, 0x21	; 33
    ecd6:	39 f4       	brne	.+14     	; 0xece6 <SD_sendCommand+0x3e>
   cmd == ERASE_BLOCK_END_ADDR ) 
   {
     arg = arg << 9;
    ecd8:	89 e0       	ldi	r24, 0x09	; 9
    ecda:	ee 0c       	add	r14, r14
    ecdc:	ff 1c       	adc	r15, r15
    ecde:	00 1f       	adc	r16, r16
    ece0:	11 1f       	adc	r17, r17
    ece2:	8a 95       	dec	r24
    ece4:	d1 f7       	brne	.-12     	; 0xecda <SD_sendCommand+0x32>
   }	   

SD_CS_ASSERT;
    ece6:	2c 98       	cbi	0x05, 4	; 5

SPI_transmit(cmd | 0x40); //send command, first two bits always '01'
    ece8:	89 2f       	mov	r24, r25
    ecea:	80 64       	ori	r24, 0x40	; 64
    ecec:	99 83       	std	Y+1, r25	; 0x01
    ecee:	62 d0       	rcall	.+196    	; 0xedb4 <SPI_transmit>
SPI_transmit(arg>>24);
    ecf0:	81 2f       	mov	r24, r17
    ecf2:	60 d0       	rcall	.+192    	; 0xedb4 <SPI_transmit>
SPI_transmit(arg>>16);
    ecf4:	80 2f       	mov	r24, r16
    ecf6:	5e d0       	rcall	.+188    	; 0xedb4 <SPI_transmit>
SPI_transmit(arg>>8);
    ecf8:	8f 2d       	mov	r24, r15
    ecfa:	5c d0       	rcall	.+184    	; 0xedb4 <SPI_transmit>
SPI_transmit(arg);
    ecfc:	8e 2d       	mov	r24, r14
    ecfe:	5a d0       	rcall	.+180    	; 0xedb4 <SPI_transmit>

if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
    ed00:	99 81       	ldd	r25, Y+1	; 0x01
    ed02:	98 30       	cpi	r25, 0x08	; 8
    ed04:	11 f4       	brne	.+4      	; 0xed0a <SD_sendCommand+0x62>
  SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
    ed06:	87 e8       	ldi	r24, 0x87	; 135
    ed08:	02 c0       	rjmp	.+4      	; 0xed0e <SD_sendCommand+0x66>
else 
  SPI_transmit(0x95); 
    ed0a:	85 e9       	ldi	r24, 0x95	; 149
    ed0c:	99 83       	std	Y+1, r25	; 0x01
    ed0e:	52 d0       	rcall	.+164    	; 0xedb4 <SPI_transmit>
    ed10:	99 81       	ldd	r25, Y+1	; 0x01
//Arguments	: unsigned char (8-bit command value)
// 			  & unsigned long (32-bit command argument)
//return	: unsigned char; response byte
//******************************************************************
unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)
{
    ed12:	00 e0       	ldi	r16, 0x00	; 0
    ed14:	02 c0       	rjmp	.+4      	; 0xed1a <SD_sendCommand+0x72>
SPI_transmit(arg);

if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
  SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
else 
  SPI_transmit(0x95); 
    ed16:	01 50       	subi	r16, 0x01	; 1

while((response = SPI_receive()) == 0xff) //wait response
   if(retry++ > 0xfe) break; //time out error
    ed18:	b9 f0       	breq	.+46     	; 0xed48 <SD_sendCommand+0xa0>
if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
  SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
else 
  SPI_transmit(0x95); 

while((response = SPI_receive()) == 0xff) //wait response
    ed1a:	99 83       	std	Y+1, r25	; 0x01
    ed1c:	51 d0       	rcall	.+162    	; 0xedc0 <SPI_receive>
    ed1e:	18 2f       	mov	r17, r24
    ed20:	99 81       	ldd	r25, Y+1	; 0x01
    ed22:	8f 3f       	cpi	r24, 0xFF	; 255
    ed24:	c1 f3       	breq	.-16     	; 0xed16 <SD_sendCommand+0x6e>
   if(retry++ > 0xfe) break; //time out error

if(response == 0x00 && cmd == 58)  //checking response of CMD58
    ed26:	88 23       	and	r24, r24
    ed28:	79 f4       	brne	.+30     	; 0xed48 <SD_sendCommand+0xa0>
    ed2a:	9a 33       	cpi	r25, 0x3A	; 58
    ed2c:	69 f4       	brne	.+26     	; 0xed48 <SD_sendCommand+0xa0>
{
  status = SPI_receive() & 0x40;     //first byte of the OCR register (bit 31:24)
    ed2e:	48 d0       	rcall	.+144    	; 0xedc0 <SPI_receive>
  if(status == 0x40) SDHC_flag = 1;  //we need it to verify SDHC card
    ed30:	86 ff       	sbrs	r24, 6
    ed32:	04 c0       	rjmp	.+8      	; 0xed3c <SD_sendCommand+0x94>
    ed34:	81 e0       	ldi	r24, 0x01	; 1
    ed36:	80 93 a9 01 	sts	0x01A9, r24
    ed3a:	02 c0       	rjmp	.+4      	; 0xed40 <SD_sendCommand+0x98>
  else SDHC_flag = 0;
    ed3c:	10 92 a9 01 	sts	0x01A9, r1

  SPI_receive(); //remaining 3 bytes of the OCR register are ignored here
    ed40:	3f d0       	rcall	.+126    	; 0xedc0 <SPI_receive>
  SPI_receive(); //one can use these bytes to check power supply limits of SD
    ed42:	3e d0       	rcall	.+124    	; 0xedc0 <SPI_receive>
  SPI_receive(); 
    ed44:	3d d0       	rcall	.+122    	; 0xedc0 <SPI_receive>
    ed46:	10 e0       	ldi	r17, 0x00	; 0
}

SPI_receive(); //extra 8 CLK
    ed48:	3b d0       	rcall	.+118    	; 0xedc0 <SPI_receive>
SD_CS_DEASSERT;
    ed4a:	2c 9a       	sbi	0x05, 4	; 5

return response; //return state
}
    ed4c:	81 2f       	mov	r24, r17
    ed4e:	21 96       	adiw	r28, 0x01	; 1
    ed50:	e6 e0       	ldi	r30, 0x06	; 6
    ed52:	e2 c0       	rjmp	.+452    	; 0xef18 <__epilogue_restores__+0x18>

0000ed54 <SD_readSingleBlock>:
//Arguments	: none
//return	: unsigned char; will be 0 if no error,
// 			  otherwise the response byte will be sent
//******************************************************************
unsigned char SD_readSingleBlock(unsigned long startBlock)
{
    ed54:	1f 93       	push	r17
    ed56:	cf 93       	push	r28
    ed58:	df 93       	push	r29
    ed5a:	ab 01       	movw	r20, r22
    ed5c:	bc 01       	movw	r22, r24
unsigned char response;
unsigned int i, retry=0;

 response = SD_sendCommand(READ_SINGLE_BLOCK, startBlock); //read a Block command
    ed5e:	81 e1       	ldi	r24, 0x11	; 17
    ed60:	a3 df       	rcall	.-186    	; 0xeca8 <SD_sendCommand>
    ed62:	18 2f       	mov	r17, r24
 
 if(response != 0x00)
    ed64:	88 23       	and	r24, r24
    ed66:	e9 f4       	brne	.+58     	; 0xeda2 <SD_readSingleBlock+0x4e>
 {
	 return response; //check for SD status: 0x00 - OK (No flags set)
 }	 

SD_CS_ASSERT;
    ed68:	2c 98       	cbi	0x05, 4	; 5

retry = 0;
while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
    ed6a:	cf ef       	ldi	r28, 0xFF	; 255
    ed6c:	df ef       	ldi	r29, 0xFF	; 255
    ed6e:	06 c0       	rjmp	.+12     	; 0xed7c <SD_readSingleBlock+0x28>
  if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out
    ed70:	20 97       	sbiw	r28, 0x00	; 0
    ed72:	19 f4       	brne	.+6      	; 0xed7a <SD_readSingleBlock+0x26>
    ed74:	2c 9a       	sbi	0x05, 4	; 5
    ed76:	11 e0       	ldi	r17, 0x01	; 1
    ed78:	14 c0       	rjmp	.+40     	; 0xeda2 <SD_readSingleBlock+0x4e>
    ed7a:	21 97       	sbiw	r28, 0x01	; 1
 }	 

SD_CS_ASSERT;

retry = 0;
while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
    ed7c:	21 d0       	rcall	.+66     	; 0xedc0 <SPI_receive>
    ed7e:	8e 3f       	cpi	r24, 0xFE	; 254
    ed80:	b9 f7       	brne	.-18     	; 0xed70 <SD_readSingleBlock+0x1c>
    ed82:	c0 e0       	ldi	r28, 0x00	; 0
    ed84:	d0 e0       	ldi	r29, 0x00	; 0
  if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out

for(i=0; i<512; i++) //read 512 bytes
  sd_buffer[i] = SPI_receive();
    ed86:	1c d0       	rcall	.+56     	; 0xedc0 <SPI_receive>
    ed88:	fe 01       	movw	r30, r28
    ed8a:	eb 52       	subi	r30, 0x2B	; 43
    ed8c:	fe 4f       	sbci	r31, 0xFE	; 254
    ed8e:	80 83       	st	Z, r24

retry = 0;
while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
  if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out

for(i=0; i<512; i++) //read 512 bytes
    ed90:	21 96       	adiw	r28, 0x01	; 1
    ed92:	82 e0       	ldi	r24, 0x02	; 2
    ed94:	c0 30       	cpi	r28, 0x00	; 0
    ed96:	d8 07       	cpc	r29, r24
    ed98:	b1 f7       	brne	.-20     	; 0xed86 <SD_readSingleBlock+0x32>
  sd_buffer[i] = SPI_receive();

SPI_receive(); //receive incoming CRC (16-bit), CRC is ignored here
    ed9a:	12 d0       	rcall	.+36     	; 0xedc0 <SPI_receive>
SPI_receive();
    ed9c:	11 d0       	rcall	.+34     	; 0xedc0 <SPI_receive>

SPI_receive(); //extra 8 clock pulses
    ed9e:	10 d0       	rcall	.+32     	; 0xedc0 <SPI_receive>
SD_CS_DEASSERT;
    eda0:	2c 9a       	sbi	0x05, 4	; 5

return 0;
}
    eda2:	81 2f       	mov	r24, r17
    eda4:	df 91       	pop	r29
    eda6:	cf 91       	pop	r28
    eda8:	1f 91       	pop	r17
    edaa:	08 95       	ret

0000edac <spi_init>:

//SPI initialize for SD card
//clock rate: 125Khz
void spi_init(void)
{
SPCR = 0x52; //setup SPI: Master mode, MSB first, SCK phase low, SCK idle low
    edac:	82 e5       	ldi	r24, 0x52	; 82
    edae:	8c bd       	out	0x2c, r24	; 44
SPSR = 0x00;
    edb0:	1d bc       	out	0x2d, r1	; 45
}
    edb2:	08 95       	ret

0000edb4 <SPI_transmit>:

unsigned char SPI_transmit(unsigned char data)
{
// Start transmission
SPDR = data;
    edb4:	8e bd       	out	0x2e, r24	; 46

// Wait for transmission complete
while(!(SPSR & (1<<SPIF)));
    edb6:	0d b4       	in	r0, 0x2d	; 45
    edb8:	07 fe       	sbrs	r0, 7
    edba:	fd cf       	rjmp	.-6      	; 0xedb6 <SPI_transmit+0x2>
data = SPDR;
    edbc:	8e b5       	in	r24, 0x2e	; 46

return(data);
}
    edbe:	08 95       	ret

0000edc0 <SPI_receive>:
unsigned char SPI_receive(void)
{
unsigned char data;
// Wait for reception complete

SPDR = 0xff;
    edc0:	8f ef       	ldi	r24, 0xFF	; 255
    edc2:	8e bd       	out	0x2e, r24	; 46
while(!(SPSR & (1<<SPIF)));
    edc4:	0d b4       	in	r0, 0x2d	; 45
    edc6:	07 fe       	sbrs	r0, 7
    edc8:	fd cf       	rjmp	.-6      	; 0xedc4 <SPI_receive+0x4>
data = SPDR;
    edca:	8e b5       	in	r24, 0x2e	; 46

// Return data register
return data;
}
    edcc:	08 95       	ret

0000edce <uart_init>:
	UBRRL = UBRR_VAL & 0xFF;
	
	UCSRB |= (1<<RXEN)|(1<<TXEN);
	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);	// Asynchron 8N1 
#else
   UBRR0H = UBRRH_VALUE;
    edce:	10 92 c5 00 	sts	0x00C5, r1
   UBRR0L = UBRRL_VALUE;
    edd2:	84 e0       	ldi	r24, 0x04	; 4
    edd4:	80 93 c4 00 	sts	0x00C4, r24
	
	#if USE_2X
	   /* U2X-Modus erforderlich */
	   UCSR0A |= (1 << U2X0);
    edd8:	e0 ec       	ldi	r30, 0xC0	; 192
    edda:	f0 e0       	ldi	r31, 0x00	; 0
    eddc:	80 81       	ld	r24, Z
    edde:	82 60       	ori	r24, 0x02	; 2
    ede0:	80 83       	st	Z, r24
	#else
	   /* U2X-Modus nicht erforderlich */
	   UCSR0A &= ~(1 << U2X0);
	#endif
	
	UCSR0B |= (1<<RXEN0)|(1<<TXEN0);
    ede2:	e1 ec       	ldi	r30, 0xC1	; 193
    ede4:	f0 e0       	ldi	r31, 0x00	; 0
    ede6:	80 81       	ld	r24, Z
    ede8:	88 61       	ori	r24, 0x18	; 24
    edea:	80 83       	st	Z, r24
	UCSR0C = (1<<UCSZ00)|(1<<UCSZ01);	// Asynchron 8N1 
    edec:	86 e0       	ldi	r24, 0x06	; 6
    edee:	80 93 c2 00 	sts	0x00C2, r24
	
	//UCSR0B |= (1<<RXEN0)|(1<<TXEN0);
	//UCSR0C = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);	// Asynchron 8N1 
#endif	
}
    edf2:	08 95       	ret

0000edf4 <uart_rxWait>:
#ifdef MEGA32 	
	while(!(UCSRA & (1<<RXC))); 	// Wait for incomming data
	//return received data
	return UDR;
#else
	while(!(UCSR0A & (1<<RXC0))); 	// Wait for incomming data
    edf4:	80 91 c0 00 	lds	r24, 0x00C0
    edf8:	87 ff       	sbrs	r24, 7
    edfa:	fc cf       	rjmp	.-8      	; 0xedf4 <uart_rxWait>
	//return received data
	return UDR0;
    edfc:	80 91 c6 00 	lds	r24, 0x00C6
#endif
	

}
    ee00:	08 95       	ret

0000ee02 <uart_tx>:
		// Wait for empty tx buffer 
	}
	// send byte
	UDR = data; 	
#else
	while ( !(UCSR0A & (1<<UDRE0)) )
    ee02:	90 91 c0 00 	lds	r25, 0x00C0
    ee06:	95 ff       	sbrs	r25, 5
    ee08:	fc cf       	rjmp	.-8      	; 0xee02 <uart_tx>
	{
		// Wait for empty tx buffer 
	}
	// send byte
	UDR0 = data; 	
    ee0a:	80 93 c6 00 	sts	0x00C6, r24
#endif	
        
}
    ee0e:	08 95       	ret

0000ee10 <uart_checkAck>:
//	for(int i=0;i<5000;i++)
//	{
		//if received data is available
	//	if( (UCSRA & (1<<RXC)) )
		{
			uint8_t data = uart_rxWait();	
    ee10:	f1 df       	rcall	.-30     	; 0xedf4 <uart_rxWait>
						
			if(data == ACK)
    ee12:	84 30       	cpi	r24, 0x04	; 4
    ee14:	09 f4       	brne	.+2      	; 0xee18 <uart_checkAck+0x8>
//	}	
	lcd_setcursor(0,2);
				lcd_string("no ack");
				while(1);
	return 0;
};
    ee16:	08 95       	ret
						
			if(data == ACK)
			{
				return ACK;
			}
			else if(data == NACK)
    ee18:	85 30       	cpi	r24, 0x05	; 5
    ee1a:	39 f4       	brne	.+14     	; 0xee2a <uart_checkAck+0x1a>
			{
				lcd_setcursor(0,2);
    ee1c:	80 e0       	ldi	r24, 0x00	; 0
    ee1e:	62 e0       	ldi	r22, 0x02	; 2
    ee20:	05 dc       	rcall	.-2038   	; 0xe62c <lcd_setcursor>
				lcd_string("nack");
    ee22:	82 e8       	ldi	r24, 0x82	; 130
    ee24:	91 e0       	ldi	r25, 0x01	; 1
    ee26:	17 dc       	rcall	.-2002   	; 0xe656 <lcd_string>
    ee28:	ff cf       	rjmp	.-2      	; 0xee28 <uart_checkAck+0x18>
			}
		
		}

//	}	
	lcd_setcursor(0,2);
    ee2a:	80 e0       	ldi	r24, 0x00	; 0
    ee2c:	62 e0       	ldi	r22, 0x02	; 2
    ee2e:	fe db       	rcall	.-2052   	; 0xe62c <lcd_setcursor>
				lcd_string("no ack");
    ee30:	87 e8       	ldi	r24, 0x87	; 135
    ee32:	91 e0       	ldi	r25, 0x01	; 1
    ee34:	10 dc       	rcall	.-2016   	; 0xe656 <lcd_string>
    ee36:	ff cf       	rjmp	.-2      	; 0xee36 <uart_checkAck+0x26>

0000ee38 <ui_init>:
	SIGNAL_LED_DDR		|= (1<<SIGNAL_LED); //LED pin as output
	SIGNAL_LED_PORT		&= ~(1<<SIGNAL_LED);//deactivated init
	*/

	//button
	SIGNAL_BUTTON_DDR	&= ~(1<<SIGNAL_BUTTON); //button pin as input
    ee38:	3a 98       	cbi	0x07, 2	; 7
	SIGNAL_BUTTON_PORT	|= (1<<SIGNAL_BUTTON);	 //pull up active
    ee3a:	42 9a       	sbi	0x08, 2	; 8
}
    ee3c:	08 95       	ret

0000ee3e <ui_isButtonPressed>:
};
*/
//-------------------------------------------------------
uint8_t ui_isButtonPressed()
{
	return (ENCODER_BUTTON==0);
    ee3e:	81 e0       	ldi	r24, 0x01	; 1
    ee40:	32 99       	sbic	0x06, 2	; 6
    ee42:	80 e0       	ldi	r24, 0x00	; 0
    ee44:	08 95       	ret

0000ee46 <__mulsi3>:
    ee46:	62 9f       	mul	r22, r18
    ee48:	d0 01       	movw	r26, r0
    ee4a:	73 9f       	mul	r23, r19
    ee4c:	f0 01       	movw	r30, r0
    ee4e:	82 9f       	mul	r24, r18
    ee50:	e0 0d       	add	r30, r0
    ee52:	f1 1d       	adc	r31, r1
    ee54:	64 9f       	mul	r22, r20
    ee56:	e0 0d       	add	r30, r0
    ee58:	f1 1d       	adc	r31, r1
    ee5a:	92 9f       	mul	r25, r18
    ee5c:	f0 0d       	add	r31, r0
    ee5e:	83 9f       	mul	r24, r19
    ee60:	f0 0d       	add	r31, r0
    ee62:	74 9f       	mul	r23, r20
    ee64:	f0 0d       	add	r31, r0
    ee66:	65 9f       	mul	r22, r21
    ee68:	f0 0d       	add	r31, r0
    ee6a:	99 27       	eor	r25, r25
    ee6c:	72 9f       	mul	r23, r18
    ee6e:	b0 0d       	add	r27, r0
    ee70:	e1 1d       	adc	r30, r1
    ee72:	f9 1f       	adc	r31, r25
    ee74:	63 9f       	mul	r22, r19
    ee76:	b0 0d       	add	r27, r0
    ee78:	e1 1d       	adc	r30, r1
    ee7a:	f9 1f       	adc	r31, r25
    ee7c:	bd 01       	movw	r22, r26
    ee7e:	cf 01       	movw	r24, r30
    ee80:	11 24       	eor	r1, r1
    ee82:	08 95       	ret

0000ee84 <__udivmodsi4>:
    ee84:	a1 e2       	ldi	r26, 0x21	; 33
    ee86:	1a 2e       	mov	r1, r26
    ee88:	aa 1b       	sub	r26, r26
    ee8a:	bb 1b       	sub	r27, r27
    ee8c:	fd 01       	movw	r30, r26
    ee8e:	0d c0       	rjmp	.+26     	; 0xeeaa <__udivmodsi4_ep>

0000ee90 <__udivmodsi4_loop>:
    ee90:	aa 1f       	adc	r26, r26
    ee92:	bb 1f       	adc	r27, r27
    ee94:	ee 1f       	adc	r30, r30
    ee96:	ff 1f       	adc	r31, r31
    ee98:	a2 17       	cp	r26, r18
    ee9a:	b3 07       	cpc	r27, r19
    ee9c:	e4 07       	cpc	r30, r20
    ee9e:	f5 07       	cpc	r31, r21
    eea0:	20 f0       	brcs	.+8      	; 0xeeaa <__udivmodsi4_ep>
    eea2:	a2 1b       	sub	r26, r18
    eea4:	b3 0b       	sbc	r27, r19
    eea6:	e4 0b       	sbc	r30, r20
    eea8:	f5 0b       	sbc	r31, r21

0000eeaa <__udivmodsi4_ep>:
    eeaa:	66 1f       	adc	r22, r22
    eeac:	77 1f       	adc	r23, r23
    eeae:	88 1f       	adc	r24, r24
    eeb0:	99 1f       	adc	r25, r25
    eeb2:	1a 94       	dec	r1
    eeb4:	69 f7       	brne	.-38     	; 0xee90 <__udivmodsi4_loop>
    eeb6:	60 95       	com	r22
    eeb8:	70 95       	com	r23
    eeba:	80 95       	com	r24
    eebc:	90 95       	com	r25
    eebe:	9b 01       	movw	r18, r22
    eec0:	ac 01       	movw	r20, r24
    eec2:	bd 01       	movw	r22, r26
    eec4:	cf 01       	movw	r24, r30
    eec6:	08 95       	ret

0000eec8 <__prologue_saves__>:
    eec8:	2f 92       	push	r2
    eeca:	3f 92       	push	r3
    eecc:	4f 92       	push	r4
    eece:	5f 92       	push	r5
    eed0:	6f 92       	push	r6
    eed2:	7f 92       	push	r7
    eed4:	8f 92       	push	r8
    eed6:	9f 92       	push	r9
    eed8:	af 92       	push	r10
    eeda:	bf 92       	push	r11
    eedc:	cf 92       	push	r12
    eede:	df 92       	push	r13
    eee0:	ef 92       	push	r14
    eee2:	ff 92       	push	r15
    eee4:	0f 93       	push	r16
    eee6:	1f 93       	push	r17
    eee8:	cf 93       	push	r28
    eeea:	df 93       	push	r29
    eeec:	cd b7       	in	r28, 0x3d	; 61
    eeee:	de b7       	in	r29, 0x3e	; 62
    eef0:	ca 1b       	sub	r28, r26
    eef2:	db 0b       	sbc	r29, r27
    eef4:	0f b6       	in	r0, 0x3f	; 63
    eef6:	f8 94       	cli
    eef8:	de bf       	out	0x3e, r29	; 62
    eefa:	0f be       	out	0x3f, r0	; 63
    eefc:	cd bf       	out	0x3d, r28	; 61
    eefe:	09 94       	ijmp

0000ef00 <__epilogue_restores__>:
    ef00:	2a 88       	ldd	r2, Y+18	; 0x12
    ef02:	39 88       	ldd	r3, Y+17	; 0x11
    ef04:	48 88       	ldd	r4, Y+16	; 0x10
    ef06:	5f 84       	ldd	r5, Y+15	; 0x0f
    ef08:	6e 84       	ldd	r6, Y+14	; 0x0e
    ef0a:	7d 84       	ldd	r7, Y+13	; 0x0d
    ef0c:	8c 84       	ldd	r8, Y+12	; 0x0c
    ef0e:	9b 84       	ldd	r9, Y+11	; 0x0b
    ef10:	aa 84       	ldd	r10, Y+10	; 0x0a
    ef12:	b9 84       	ldd	r11, Y+9	; 0x09
    ef14:	c8 84       	ldd	r12, Y+8	; 0x08
    ef16:	df 80       	ldd	r13, Y+7	; 0x07
    ef18:	ee 80       	ldd	r14, Y+6	; 0x06
    ef1a:	fd 80       	ldd	r15, Y+5	; 0x05
    ef1c:	0c 81       	ldd	r16, Y+4	; 0x04
    ef1e:	1b 81       	ldd	r17, Y+3	; 0x03
    ef20:	aa 81       	ldd	r26, Y+2	; 0x02
    ef22:	b9 81       	ldd	r27, Y+1	; 0x01
    ef24:	ce 0f       	add	r28, r30
    ef26:	d1 1d       	adc	r29, r1
    ef28:	0f b6       	in	r0, 0x3f	; 63
    ef2a:	f8 94       	cli
    ef2c:	de bf       	out	0x3e, r29	; 62
    ef2e:	0f be       	out	0x3f, r0	; 63
    ef30:	cd bf       	out	0x3d, r28	; 61
    ef32:	ed 01       	movw	r28, r26
    ef34:	08 95       	ret

0000ef36 <_exit>:
    ef36:	f8 94       	cli

0000ef38 <__stop_program>:
    ef38:	ff cf       	rjmp	.-2      	; 0xef38 <__stop_program>
